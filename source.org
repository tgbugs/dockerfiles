# -*- orgstrap-cypher: sha256; orgstrap-norm-func-name: orgstrap-norm-func--prp-1\.1; orgstrap-block-checksum: c7cdde86afa872b74438254451b1945f7bce60efa3e30a94dbda03d1c39a4112; -*-
# [[orgstrap][jump to the orgstrap block for this file]]
#+title: Literate source for docker files

#+property: header-args :eval no-export
#+property: header-args:dockerfile :mkdirp yes :comments link :var BUILDKIT_PROGRESS="plain"

#+name: shebang
#+begin_src bash
{ __p=$(mktemp -d); touch ${__p}/=; chmod +x ${__p}/=; __op=$PATH; PATH=${__p}:$PATH;} > ${null="/dev/null"}
$file= $MyInvocation.MyCommand.Source
$ErrorActionPreference= "silentlycontinue"
file=$0
args=$@
$ErrorActionPreference= "Continue"
{ PATH=$__op; rm ${__p}/=; rmdir ${__p}; } > $null
emacs -batch -no-site-file -load ~/.emacs.d/orgstrap-developer-checksums.el -load ~/.emacs.d/orgstrap-batch-helper.el -visit "${file}" -- $args
exit
<# powershell open
#+end_src

* Setup
** Server
Docker files in this repo use buildkit features. To enable it include
the following in [[/etc/docker/daemon.json]].
#+begin_src json :tangle /etc/docker/daemon.json :tangle no
{"experimental": true,
 "features": {"buildkit": true}}
#+end_src

** Client
Building the precursor images in =gentoo/stage3= for this repo from
[[https://github.com/gentoo/gentoo-docker-images][scratch]] requires
the =buildx= extension which requires experimental features to be
enabled in the client.
#+begin_src json :tangle ~/.docker/config.json :tangle no
{"experimental": "enabled"}
#+end_src

* Ops
#+begin_src bash
docker pull gentoo/stage3:amd64-musl-hardened
docker pull gentoo/portage
docker create -v /usr/portage --name local-portage-snap gentoo/portage:latest /bin/true
#+end_src

If you are bootstrapping this file from scratch you will need to build
dependent images in order.


Run package host
#+begin_src bash
# mkdir -p ~/files/binpkgs/musl
# mkdir -p ~/files/binpkgs/musl-x
pushd ~/files/binpkgs
python -m http.server 8089 --bind 127.0.0.1
#+end_src

To prepare a fresh cycle of images.
#+name: workflow
#+begin_src screen :noweb yes :session org-session :results none
# docker pull gentoo/stage3:amd64-musl-hardened
# docker pull gentoo/portage:latest

# TODO if portage changed ...
# docker rm local-repos-snap
# docker create -v /var/db/repos --name local-repos-snap tgbugs/repos:latest /bin/true
pushd ~/git/dockerfiles
./source.org --tangle  # TODO --tangle does nothing right now because the behavior is default
function run () {
local REPOS
local QPKG
local QPKGX
<<&musl-build-user>> || return 1;
<<&musl-build-portage-maven>> || return 2;
<<&musl-build-profile>> || return 3;
  <<&musl-build-eselect-repository>> || return 4;
    [ -z $REPOS ] || \
    <<&repos-build-repos>> || return 5;
    <<&musl-build-updated>> || return 6;
      <<&musl-build-updated-user>> || return 7;
      # FIXME quickpkg should not repackage
      [ -z $QPKG ] || \
      <<&musl-run-updated-quickpkg>> || return 8;

      <<&musl-build-package-builder-nox>> || return 9;
      <<&musl-build-binrepos-nox>> || return 10;

      # XXX this is the point at which things split into musl and musl/x
      <<&musl-build-xorg>> || return 11;
      # FIXME quickpkg should not repackage
      [ -z $QPKGX ] || \
      <<&musl-run-xorg-quickpkg>> || return 12;

      <<&musl-build-package-builder>> || return 13;
      <<&musl-build-binrepos>> || return 14;
}
run
# package host
# build a bunch of packages
popd
#+end_src

#+begin_src screen :noweb yes :session org-session :results none
<<&musl-run-updated-user>>
#+end_src

* Next
** TODO a better way
The primary issue here is that it really is not safe to compose after
merge because the power and flexibility of portage happen before
merge, and are quite state dependent after the fact. The key then is
to be able to create images that do compose well, and the only at
the very end materialize them by installing all the packages at once.

The problem is that you give up the utility of the docker layers, but
if we are installing binary packages that have been build on a
separate system then we know that we won't encounter build errors.

The final obstacle to full composability in this way is the issue of
incompatible use flags, but I think it is safe to say that it is not
really possible to solve that problem.

This consideration suggests that the layers of docker images, while
useful, are fundamentally at odds with composability when there are
files inside images that track state (e.g. =/var/lib/portage/world=).

** TODO condense use flags
At the moment we keep use flags with packages and try to keep them
mostly orthogonal to each other. However, at a certain point it is
going to be easier to maintain a single shared use flag image that
will be synchronized across all images. Granular control is nice from
a learning and minimal specification point of view, but from an
engineering an maintenance point of view it is vastly easier easier to
maintain a single shared use flag image that will be synchronized
across all images. Granular control is nice from a learning and
minimal specification point of view, but from an engineering an
maintenance point of view it is simpler to unify the individual image
environments into a single file.
** TODO create an image to build packages
Rebuilding images is wasteful when nothing has changed, and packages
and install properly to maintain the correct state of the image. While
=COPY --from= works, it mangles things like =/var/lib/portage/world=,
and if use flags were changed on a dependency by another source image
then unusual and unexpected errors could occur. This is another reason
to move to manage use flags one or two images, one image for cases
where X11 is not needed, and another where it is.

In fact, I'm fairly certain that having a shared use flag environment
is necessary for it to be possible to safely compose packages and
images. Composition across environments requires something like nix
where each package carries around its own environment. It might be
possible to do better than this by allowing composition in cases where
the environments are compatible, but that would still require
computation at composition time, you can't just layer images an expect
things to work.

alternately mount =/var/cache/binpkgs= and then run quickpkg or
something devious like that
** TODO separate user image
Should be able to =COPY --from=tgbugs/musl:user= across all images.
build the user image from a base that has next to nothing in it
add the user and group to the system and then copy that minimal
user stuff in, most of the time there isn't any fancy installation
that needed to be done, and we could just copy the user directory
when building from scratch
* repos
Overlays can take up quite a bit of space so it is better to mount
them the same way we mount the gentoo repo during build so that we can
keep the images a bit slimmer. We can publish the build images
independently, and it is also worth noting that from a reproducibility
perspective the exact ebuilds are stored in file:/var/db/pkg/.
*** build
#+name: &repos-build-repos
#+begin_src bash
docker build \
--no-cache \
--tag tgbugs/repos:latest \
--file repos/Dockerfile .
#+end_src
*** file
#+begin_src dockerfile :tangle ./repos/Dockerfile
FROM tgbugs/musl:eselect-repository as builder

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emaint sync --repo musl

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emaint sync --repo tgbugs-overlay

FROM busybox:latest

WORKDIR /
COPY --from=builder /var/db/repos /var/db/repos
COPY --from=gentoo/portage:latest /var/db/repos/gentoo /var/db/repos/gentoo
CMD /bin/true
VOLUME /var/db/repos
#+end_src
* musl
Pushes to https://hub.docker.com/r/tgbugs/musl. \\
Derived from [[https://hub.docker.com/r/gentoo/stage3/tags?page=1&ordering=last_updated&name=musl-hardened][gentoo/stage3:amd64-musl-hardened]] \\
Further derived from https://ftp-osl.osuosl.org/pub/gentoo/releases/amd64/autobuilds/current-stage3-amd64-musl-hardened/ \\
and from https://gitweb.gentoo.org/proj/releng.git/tree/releases/specs/amd64/musl/stage3-hardened.spec
** profile
:PROPERTIES:
:header-args:conf: :mkdirp yes
:END:
The right way to do this is to create two custom profiles on top of musl-hardened.

https://wiki.gentoo.org/wiki/Profile_(Portage)#custom

Modifications to use flags and other system settings and
configurations that are easier to keep in a single location.
# FIXME this may need to be versioned, or we just force rebuild on all
# the images from scratch which we often have to do anyway, though some
# packages may not be affect by profile changes
*** build
#+name: &musl-build-profile
#+begin_src bash
docker build \
--tag tgbugs/musl:profile \
--file musl/profile/Dockerfile musl/profile
#+end_src
*** file
# https://github.com/GoogleContainerTools/skaffold/issues/5015
# https://github.com/moby/buildkit/issues/1271
# ?? no not the issue?
#+begin_src dockerfile :noweb yes :tangle ./musl/profile/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD local var/db/repos/local
ADD local.conf etc/portage/repos.conf/local.conf
ADD musl.conf etc/portage/binrepos.conf/musl.conf

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src
*** etc
**** binrepos.conf
# XXX this will need to be overwritten by the x profile later
#+begin_src conf :noweb yes :tangle ./musl/profile/musl.conf
<<musl-binrepos.conf-nox>>
#+end_src

**** repos.conf
#+begin_src conf :tangle ./musl/profile/local.conf
[local]
location = /var/db/repos/local
#+end_src

*** profiles
#+begin_src conf :tangle ./musl/profile/local/metadata/layout.conf
masters = gentoo
profile-formats = portage-2
#+end_src

#+begin_src conf :tangle ./musl/profile/local/profiles/repo_name
local
#+end_src

#+begin_src conf :tangle ./musl/profile/local/profiles/profiles.desc
amd64 tgbugs/musl   dev
amd64 tgbugs/musl/x dev
#+end_src
**** common
***** parent
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/parent
gentoo:default/linux/amd64/17.0/musl/hardened
#+end_src
***** make.defaults
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/make.defaults
VIDEO_CARDS=""
#+end_src
***** mask
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/package.mask
# insurance
dev-lang/rust
dev-lang/rust-bin

# gtknor
>=gnome-base/librsvg-2.41
>x11-themes/adwaita-icon-theme-3.33
#>=media-libs/mesa-21 # FIXME temporary

# dynapad
>=media-gfx/imagemagick-7
#+end_src
***** unmask
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/package.unmask
# gtknor
<gnome-base/librsvg-2.41
#+end_src
***** accept_keywords
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/package.accept_keywords
dev-python/pipenv ~amd64
app-misc/yq ~amd64

# tgbugs-overlay
dev-db/blazegraph-bin ~amd64
dev-java/scigraph-bin ~amd64
dev-scheme/racket ~amd64

# gtknor
<gnome-base/librsvg-2.41 **

# tgbugs-overlay python # XXX if we introduct pypy3 this is going to be a mess
# dev-python/pyontutils ~amd64
#+end_src
***** package.use
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/package.use
# musl performance
# ,*/* jemalloc # FIXME not sure how to enable the positive use flag

# font rendering
media-libs/freetype -cleartype-hinting

# needed to ensure that -egl doesn't introduce conflicts
x11-base/xorg-server minimal

app-editors/emacs dynamic-loading gmp json threads

# gdb don't pull in the world
sys-devel/gdb -nls -python

# pyzmq
net-libs/zeromq drafts

dev-scheme/racket cs bc cgc jit
#+end_src
***** use.mask
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/use.mask
# reduce deps
perl
gtk
cups
postscript

# reduce xorg deps
llvm
egl
gles2
gallium
dbus
vala
introspection
elogind
#+end_src
**** x
***** parent
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/x/parent
..
#+end_src
***** use
#+begin_src conf :tangle ./musl/profile/local/profiles/tgbugs/musl/x/package.use
# ,*/* X # FIXME it seems that wildcards are not allowed in here so for now has to be done later

media-libs/freetype harfbuzz

app-editors/emacs gui Xaw3d xft # XXX note that latest reccomendations are to use harfbuzz + cairo for text shaping (or something like that)
app-emacs/emacs-common gui

# avoid extra deps
dev-util/cmake -ncurses

# scigraph
x11-base/xorg-server xvfb
#+end_src

** user
#+name: &musl-build-user
#+begin_src bash
docker build \
--tag tgbugs/musl:user \
--file musl/user/Dockerfile .
#+end_src

# FIXME this is sufficient to create the default set of files and directories for the user
# however it is not able to deal with the fact that groupadd and useradd still must be run
# on the host system, which leads me to think that the only composability we are going to
# get here is via noweb :/ the primary issue is /etc/groups and other similar things

#+name: &run-user-noskel
#+begin_src bash :eval never
groupadd -g ${UID} ${USER_NAME} \
&& useradd -M -u ${UID} -g ${UID} ${USER_NAME}
#+end_src


Block to be nowebbed for the user creation portion of the images.
Should be +followed+ preceded? by a =COPY --from= that was built by
layering on top of the image we build below.

#+name: &musl-file-user-base
#+begin_src dockerfile :noweb yes
ARG UID=1000
ARG USER_NAME=user

RUN \
<<&run-user-noskel>>

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

#+begin_src dockerfile :noweb yes :tangle ./musl/user/Dockerfile
FROM gentoo/stage3:amd64-musl-hardened as builder

ARG UID=1000
ARG USER_NAME=user

WORKDIR /build

RUN \
groupadd -g ${UID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${UID} -g ${UID} -d /build/home/${USER_NAME} ${USER_NAME}

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

** portage-maven
Hack to make it possible to install from maven using portage.
*** build
#+name: &musl-build-portage-maven
#+begin_src bash
docker build \
--tag tgbugs/musl:portage-maven \
--file musl/portage-maven/Dockerfile musl/portage-maven
#+end_src

*** file
The UID for portage is static so it is ok to hard code it [fn::
https://api.gentoo.org/uid-gid.txt
https://wiki.gentoo.org/wiki/Project:Quality_Assurance/UID_GID_Assignment].

#+name: &portage-maven-settings
#+begin_src xml :tangle ./musl/portage-maven/settings.xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd">
  <localRepository>/var/tmp/portage/.m2/repository</localRepository>
</settings>
#+end_src

#+name: &run-portage-maven-1
#+begin_src bash :eval never :noweb yes
# mkdir -p var/lib/portage/home/.m2 \
chown -R 250:250 var/lib/portage \
&& mkdir -p var/tmp/portage/.m2/repository \
&& chown -R 250:250 var/tmp/portage
#+end_src

#+begin_src dockerfile :noweb yes :tangle ./musl/portage-maven/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD settings.xml var/lib/portage/home/.m2/settings.xml

RUN \
<<&run-portage-maven-1>>

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

** eselect-repository
This is where everything starts. The profile has to be set here etc.

*** run
#+begin_src bash
docker run \
--volumes-from local-portage-snap \
-v ~/files/binpkgs/musl:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-it tgbugs/musl:eselect-repository
#+end_src

*** build
# FIXME --network host is ok for now, but we should probably try to
# switch to using --ssh or something I think this may be ok though
# because it is only needed during the earliest phases of bootstrap
# and then not used again afterward
#+name: &musl-build-eselect-repository
#+begin_src bash
docker build \
--tag tgbugs/musl:eselect-repository \
--network host \
--add-host local.binhost:127.0.0.1 \
--file musl/eselect-repository/Dockerfile .
#+end_src

*** file

#+begin_src dockerfile :tangle ./musl/eselect-repository/Dockerfile
FROM gentoo/stage3:amd64-musl-hardened

ARG ARCHIVE
ARG PYTHON_TARGETS  # use if there are issues with mismatched python targets

COPY --from=tgbugs/musl:profile / /

RUN \
mkdir /etc/portage/package.accept_keywords \
;  mkdir /etc/portage/package.env \
;  mkdir /etc/portage/package.mask \
;  mkdir /etc/portage/package.unmask \
;  mkdir /etc/portage/package.use \
;  mkdir /etc/portage/repos.conf \
|| true

RUN \
eselect profile set local:tgbugs/musl

RUN \
echo "MAKEOPTS=\"-j$(nproc)\"" >> /etc/portage/make.conf \
&& [[ -z ${PYTHON_TARGETS} ]] || \
   echo "*/* PYTHON_TARGETS: -* ${PYTHON_TARGETS}" >> /etc/portage/package.use/00-base
# XXX setting PORTAGE_BINHOSTS has to come later? maybe as an envar?

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   --getbinpkg \
   dev-vcs/git \
   eselect-repository \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
eselect repository enable musl

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
eselect repository add tgbugs-overlay git https://github.com/tgbugs/tgbugs-overlay.git
#+end_src
# TODO should we be adding the mount points here as well or is that not necessary?

** updated
*** file
Produce an up-to-date base image for =amd64-hardened-musl= from the
latest stage3 image including the
[[https://github.com/gentoo/musl][musl overlay]] as noted on the
[[https://wiki.gentoo.org/wiki/Project:Hardened_musl#Working_with_musl][wiki]].

At the moment the docker images are generated far more frequently than
the underlying stage3 tarballs are updated, so there are two docker
files, one for building the first time and another for running routine
emerge updates until a new stage3 is released.

Alternately, one way to avoid rebuilds is to build packages and store
them across rebuilds. This will take more work, but ultimately might
be a bit more reproducible since we would avoid the issues with having
an image building =FROM= a prior version of itself.

#+name: &musl/updated
#+begin_src dockerfile :tangle ./musl/updated/Dockerfile
FROM tgbugs/musl:eselect-repository

# FIXME eselect new read all probably
# FIXME TODO --getpkg for rebootstrap during development

# exclude gcc during first update since it is slow, it will be updated when running remerge.Dockerfile
RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q -uDN @world \
   --getbinpkg \
   --keep-going \
   --exclude sys-devel/gcc \
   --exclude sys-process/procps \
|| echo "something failed to build" \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

#+name: &musl/updated-remerge
#+begin_src dockerfile :tangle ./musl/updated/remerge.Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q -uDN @world \
   --getbinpkg \
   --keep-going \
   --exclude sys-process/procps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

*** build
#+name: &musl-build-updated
#+begin_src screen :session org-session
docker build \
--tag tgbugs/musl:updated \
--network host \
--add-host local.binhost:127.0.0.1 \
--file musl/updated/Dockerfile .
#+end_src

*** rebuild
#+begin_src bash
docker build \
--tag tgbugs/musl:updated-remerge \
--file musl/updated/remerge.Dockerfile .

# check that everything works as expected (and that there were changes at all)
docker run -it tgbugs/musl:updated-remerge

# rename the image
docker image tag tgbugs/musl:updated-remerge tgbugs/musl:updated
#+end_src

*** run
#+name: &musl-run-updated
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/musl:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
-it tgbugs/musl:updated
#+end_src
** updated-user
An example of how to compose user images to minimize size.
*** run
#+begin_src bash
docker run -it tgbugs/musl:updated-user
#+end_src

*** build
#+name: &musl-build-updated-user
#+begin_src bash
docker build \
--tag tgbugs/musl:updated-user \
--build-arg UID=${UID} \
--file musl/updated-user/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :noweb yes :tangle ./musl/updated-user/Dockerfile
FROM tgbugs/musl:updated

# change this line to copy from whatever user image you need
COPY --from=tgbugs/musl:user / /

<<&musl-file-user-base>>
#+end_src

** xorg
*** run
#+name: &musl-run-xorg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/musl:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
-it tgbugs/musl:xorg
#+end_src
*** build
#+name: &musl-build-xorg
#+begin_src screen :session org-session
docker build \
--tag tgbugs/musl:xorg \
--network host \
--add-host local.binhost:127.0.0.1 \
--file musl/xorg/Dockerfile .
#+end_src

*** file
The really good news here is that portage ignores packages that were
built with mismatched use flags, so at the end of the day what we will
wind up with is a case where only packages with mismatched flags will
be build and deposited into musl-x.

#+name: musl-binrepos.conf
#+begin_src conf :tangle ./musl/xorg/musl-x.conf
[tgbugs-musl-x]
sync-uri = http://local.binhost:8089/musl-x
#+end_src

#+begin_src dockerfile :tangle ./musl/xorg/Dockerfile
FROM tgbugs/musl:updated

ADD musl-x.conf /etc/portage/binrepos.conf/musl-x.conf

RUN \
eselect profile set local:tgbugs/musl/x

# FIXME I think we have to update binhosts here

RUN \
echo '*/* X' >> /etc/portage/package.use/20-xorg

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q -uDN @world \
   --getbinpkg \
   --keep-going \
   --exclude sys-process/procps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

# FIXME TODO install freetype here without harfbuzz to avoid the circular dependency

#+end_src
** package-builder
*** populate 0
Yes it is kind of annoying to fully split the packages here when many of them don't actually
change, but I don't have an easy way to detect when it is safe to symlink a nox build into
the X build, though I think we can create a processes that would check the packages and to
see whether they have identical metadata and then remove one and symlink the other ....

# it is safe to use --include-config here becauseit is done before any modifications are made
# FIXME TODO need a way to ignore existing exact matches unless we override
#+name: &musl-run-xorg-quickpkg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/musl-x:/var/cache/binpkgs \
--rm \
tgbugs/musl:xorg \
quickpkg "*/*" --include-config y
#+end_src

*** run
#+begin_src bash
function build_package () {
echo docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/musl-x:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
--rm \
tgbugs/musl:package-builder \
$@
}
# --buildpkgonly -j4 -q --keep-going
#+end_src

#+begin_src bash
build_package sh -c "USE=-harfbuzz emerge -1q freetype"
# and here we see why I keep harfbuzz out of the nox profile
build_package sh -c "emerge -1q freetype"
#+end_src

If there is a new package that one of your images needs add it here.
Yes, there are going to be issues with keywording that are likely going
to require updates to the profile followed by a rebuild here. I can't quite
remember whether binpkgs check use flags.
#+name: builder-portage-world
#+begin_src conf
app-portage/eix
sys-devel/gdb::musl
dev-libs/libconfig
dev-libs/libvterm
dev-libs/nss
sys-libs/db
app-arch/zip
app-editors/vim
app-editors/emacs
dev-lang/tk
dev-lang/python:3.6
dev-lang/python:3.7
dev-lang/python:3.8
dev-lang/python:3.9
dev-python/pip
dev-python/pipenv
dev-python/pyzmq
app-misc/yq
net-libs/nodejs
app-text/poppler
media-gfx/imagemagick
#+end_src

# FIXME dev-java/icedtea-bin::musl headless-awt means we have to make the nox profile explicit
# similar issue for dev-scheme/racket minimal

#+name: builder-portage-world-x
#+begin_src conf
x11-base/xorg-server
x11-libs/gtk+
media-libs/freetype
media-libs/fontconfig
media-fonts/dejavu
app-editors/gvim
dev-java/icedtea-bin::musl
dev-db/blazegraph-bin
dev-java/scigraph-bin
dev-scheme/racket
#+end_src

*** build
#+name: &musl-build-package-builder
#+begin_src bash
docker build \
--tag tgbugs/musl:package-builder \
--file musl/package-builder/Dockerfile .
#+end_src

*** file
#+name: &musl-package-builder-common
#+begin_src dockerfile

RUN \
echo 'FEATURES="${FEATURES} buildpkg"' >> /etc/portage/make.conf \
&& echo 'EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkg"' >> /etc/portage/make.conf

VOLUME /var/cache/binpkgs
#+end_src

#+begin_src dockerfile :noweb yes :tangle ./musl/package-builder/Dockerfile
FROM tgbugs/musl:xorg
<<&musl-package-builder-common>>
#+end_src
** package-builder-nox
*** populate 0
#+name: &musl-run-updated-quickpkg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/musl:/var/cache/binpkgs \
--rm \
tgbugs/musl:updated \
quickpkg "*/*" --include-config y
#+end_src

*** build
#+name: &musl-build-package-builder-nox
#+begin_src bash
docker build \
--tag tgbugs/musl:package-builder \
--file musl/package-builder/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :noweb yes :tangle ./musl/package-builder-nox/Dockerfile
FROM tgbugs/musl:updated

<<&musl-package-builder-common>>
#+end_src

** package-binhost
** binrepos
*** build
#+name: &musl-build-binrepos
#+begin_src bash
docker build \
--tag tgbugs/musl:binrepos \
--file musl/binrepos/Dockerfile musl/binrepos
#+end_src

*** file
#+name: musl-binrepos.conf
#+begin_src conf :tangle ./musl/binrepos/musl-x.conf
[tgbugs-musl-x]
sync-uri = http://local.binhost:8089/musl-x
#+end_src

#+begin_src dockerfile :noweb yes :tangle ./musl/binrepos/Dockerfile
FROM tgbugs/musl:xorg

ADD musl-x.conf /etc/portage/binrepos.conf/musl-x.conf
<<&musl-file-binrepos-common>>
#+end_src

#+name: &musl-file-binrepos-common
#+begin_src dockerfile

RUN \
echo 'EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"' >> /etc/portage/make.conf \

# consider whether it is possible to put the binhost has an ARG for the build process
# and what the tradeoffs are, I think it is better to hardcode it since we can remap
# ports etc
#+end_src

** binrepos-nox
*** build
#+name: &musl-build-binrepos-nox
#+begin_src bash
docker build \
--tag tgbugs/musl:binrepos-nox \
--file musl/binrepos-nox/Dockerfile musl/binrepos-nox
#+end_src

*** file
#+name: musl-binrepos.conf-nox
#+begin_src conf :tangle ./musl/binrepos-nox/musl.conf
[tgbugs-musl]
sync-uri = http://local.binhost:8089/musl
#+end_src

# FIXME musl.conf likely already exists
#+begin_src dockerfile :noweb yes :tangle ./musl/binrepos-nox/Dockerfile
FROM tgbugs/musl:updated

ADD musl.conf /etc/portage/binrepos.conf/musl.conf
<<&musl-file-binrepos-common>>
#+end_src

** vim
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:vim \
--file musl/vim/Dockerfile .
#+end_src

*** file
#+name: &musl/vim
#+begin_src dockerfile :tangle ./musl/vim/Dockerfile
FROM tgbugs/musl:updated as

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-editors/vim \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** gdb
If the =nls= or the =python= use flag is set for =gdb= then it will
try to link =libintl_gettext= and fail. Therefore both use flags must
be disabled when building on musl systems at this time. This should
probably be dealt with or fixed in the musl overlay. This might also
be a bug in the =gdb= build since it may need to use =-lintl=.
#+name: &gdb
#+begin_src dockerfile :tangle ./musl/gdb/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   sys-devel/gdb::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

** pip
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:pip \
--file musl/pip/Dockerfile .
#+end_src

*** file
#+name: &musl/pip
#+begin_src dockerfile :tangle ./musl/pip/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-python/pip \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** python
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:python \
--file musl/python/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/python/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q -uDN --keep-going \
   python:3.6 \
   python:3.7 \
   python:3.8 \
   python:3.9 \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true


RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q pipenv \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** nodejs
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:nodejs \
--file musl/nodejs/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/nodejs/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   net-libs/nodejs \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** fix fonts
Many other packages pull in freetype, so we have to deal with the
issue before anything else.
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:fix-fonts \
--file musl/fix-fonts/Dockerfile .
#+end_src

*** file
#+name: &fix-fonts
#+begin_src dockerfile :tangle ./musl/fix-fonts/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

# rebuild freetype without cleartype hinting
RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q media-libs/freetype \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   fontconfig \
   media-fonts/dejavu \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN \
eselect fontconfig disable 10-hinting-slight.conf \
&& eselect fontconfig enable \
   10-no-sub-pixel.conf \
   57-dejavu-sans.conf \
   57-dejavu-sans-mono.conf

VOLUME /var/cache/distfiles
#+end_src

Only enabling dejavu sans and disabling any and all hinting matters.
There isn't a way to disable antialiasing using the gentoo fontconfig
and even if you do the disabled hinting engine has different and ugly
behavior compared to =-cleartype-hinting= so not sure what is going on
for even further insanity if you enable =10-hinting-none.conf= OR
=10-unhinted.conf= *YOU WILL GET HINTING !?!?!??! WAT!?* or at least
maybe AA is enabled which does not maybe ANY sense. Probably there is
some logic which is that in order to disable some feature there is
some default that is enabled so there winds up being a difference
between there being no reference to a feature and a reference to it to
explicitly disable it. Sigh.

** xorg-old
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:xorg-old \
--file musl/xorg-old/Dockerfile .
#+end_src

# someday when we get babel configured correctly to use comint
# #+call: docker-build-musl(image="xorg")

*** file
#+begin_src dockerfile :tangle ./musl/xorg-old/Dockerfile
FROM tgbugs/musl:fix-fonts

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q \
    x11-base/xcb-proto \
    x11-base/xorg-proto \
    x11-libs/libX11 \
    x11-libs/libXau \
    x11-libs/libXdmcp \
    x11-libs/libXext \
    x11-libs/libXfixes \
    x11-libs/libXrender \
    x11-libs/libxcb \
    x11-libs/xtrans \
    x11-misc/compose-tables \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

** emacs
Emacs using the athena 3d toolkit to avoid pulling in gtk.
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:emacs
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:emacs \
--file musl/emacs/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/emacs/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-editors/emacs \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

** gtk-no-rust
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:gtk-no-rust \
--file musl/gtk-no-rust/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/gtk-no-rust/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q \
   x11-libs/gtk+ \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

** icedtea
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:icedtea \
--file musl/icedtea/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/icedtea/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q nss \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q --onlydeps \
   dev-java/icedtea-bin::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-java/icedtea-bin::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

*** legacy
The musl overlay installs icedtea-bin correctly now so this is thankfully no longer needed.
#+name: &musl/icedtea/legacy
#+begin_src dockerfile :tangle ./musl/icedtea/legacy.Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

ARG BASE="https://github.com/tgbugs/musl/releases/download/icedtea-bin-3.18.0-alpine-helper-0/"

ARG TMCH=34581ad0f14b5898abfb8d0a7ad89d560270a2e5

RUN \
eselect repository create local /usr/local/portage

# FIXME this is an evil hack that WILL expire
RUN \
mkdir -p /usr/local/portage/dev-java/icedtea-bin \
&& pushd /usr/local/portage/dev-java/icedtea-bin \
&& ln -s /var/db/repos/musl/dev-java/icedtea-bin/files \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/icedtea-bin-3.18.0.ebuild" \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/Manifest"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q nss \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q dev-java/icedtea-bin::local --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

ARG SIGH="icedtea-bin-3.18.0-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-dbg-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-doc-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-base-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-lib-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-libjpeg-x86_64-musl.tar.gz"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
pushd /var/cache/distfiles \
&& for SI in ${SIGH}; do curl -L -o "${SI}" "${BASE}${SI/-musl/}"; done \
&& popd \
&& emerge -j4 -q dev-java/icedtea-bin::local \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/cache/distfiles
#+end_src

# export failure=$(docker ps -lq)
# docker start $failure
# docker attach $failure

** protege
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:protege \
--build-arg NUID=${UID} \
--file musl/protege/Dockerfile .
#+end_src

Due to the fact that protege needs X11 running in order to create
config files.  Run the following command, change the default reasoner
to ELK, make any other changes that are needed, and then quit protege.
The second command will run automatically and commit the changes.

NOTE you must run the =protege= command manually to prevent the commit
from changing the default behavior of the container from changing its
entry point to run =protege=.

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege && \
docker commit $(docker ps -lq) tgbugs/musl:protege
#+end_src

*** file
We install pip during this step because any builds that =FROM
tgbugs/musl:protege= default to =protegeuser=.
# TODO FIXME we should be able to install protege as root
#+name: &musl/protege
#+begin_src dockerfile :noweb yes :tangle ./musl/protege/Dockerfile
FROM tgbugs/musl:icedtea

ARG ARCHIVE
ARG NUID=11741
ARG USER_NAME=protegeuser
ARG PROTEGE_VERSION="5.5.0"

# phase one build environment
RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-python/pip \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN \
groupadd -g ${NUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${NUID} -g ${NUID} -d /home/${USER_NAME} ${USER_NAME}

VOLUME /var/cache/distfiles

# the rest is run as the neurondm user
USER $USER_NAME

# phase two protege and reasoners
ARG URL_PROTEGE="https://github.com/protegeproject/protege-distribution/releases/download/v5.5.0/Protege-5.5.0-linux.tar.gz"
ARG URL_ELK="https://github.com/liveontologies/elk-reasoner/releases/download/v0.4.3/elk-distribution-0.4.3-protege-plugin.zip"
ARG URL_FACT="https://bitbucket.org/dtsarkov/factplusplus/downloads/uk.ac.manchester.cs.owl.factplusplus-P5.x-v1.6.5.jar"

RUN \
cd ~/ \
&& curl -L -O ${URL_PROTEGE} \
&& tar xvzf Protege-${PROTEGE_VERSION}-linux.tar.gz \
&& pushd Protege-${PROTEGE_VERSION} \
&& rm jre/ -r \
&& sed -i 's/^jre\/bin\/java/\/usr\/bin\/java/' run.sh \
&& sed -i 's/500M/12G/' run.sh \
&& sed -i 's/200M/5G/' run.sh \
&& sed -i 's/16M/160M/' run.sh \
&& pushd plugins \
&& curl -L -O ${URL_FACT} \
&& curl -L -O ${URL_ELK} \
&& unzip -p elk-distribution-0.4.3-protege-plugin.zip \
   elk-distribution-0.4.3-protege-plugin/org.semanticweb.elk.jar \
   > org.semanticweb.elk-0.4.3.jar \
&& rm elk-distribution-0.4.3-protege-plugin.zip \
&& popd; popd \
&& mkdir -p ~/.local/share ~/.local/bin \
&& mv Protege-${PROTEGE_VERSION} ~/.local/share/ \
&& pushd ~/.local/bin \
&& ln -s ~/.local/share/Protege-${PROTEGE_VERSION}/run.sh protege \
&& popd \
&& rm Protege-${PROTEGE_VERSION}-linux.tar.gz

ENV PATH="/home/${USER_NAME}/.local/bin:${PATH}"

# paths to preferences files
ARG PATH_CFU_1=_\!\&\!\!\`g\"\>\!\&@\!\[@\"\(\!%\`\!\|w\"@\!\&\)\!\[@\"\'\!%\`\!\`g\"\&\!%4\!@w\"\&\!\&:=
ARG PATH_CFU_2=_\!\'%\!c\!\"w\!\'w\!a@\"j\!\'%\!d\!\"p\!\'8\!bg\"f\!\(\!\!cg\"l\!\'\}\!~@\"y\!\'\`\!bg\"j\!\'\`\!cw==
ARG PATH_CFU_3=_\!\'8\!cg\"n\!#4\!c\!\"y\!\'8\!d\!\"l\!\'c\!~@\!u\!\'\`\!~\!\"p\!\(@\!bw\"y\!#4\!\}w\"v\!\(\)\!~@\!u\!\(\`\!c\!\"k\!\'%\!d\!\"l\!#4\!\`\!\"s\!\(\`\!~w\"p\!\'4\!\^@\"h\!\'4\!\}@\"n\!\'\`\!cg==
ARG PATH_CFU="${PATH_CFU_1}/${PATH_CFU_2}/${PATH_CFU_3}"

# set preferences so that protege starts in the right state the first time
# protege doesn't create this prefs file by default so we would have to do this regardless
# this helps because it prevents the search for plugins on first run so that goes faster
RUN \
pushd ~/ \
&& mkdir -p ".java/.userPrefs/${PATH_DRI_1}" \
&& chmod 0700 ".java/.userPrefs" \
&& mkdir -p ".java/.userPrefs/${PATH_CFU}" \
&& echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<!DOCTYPE map SYSTEM "http://java.sun.com/dtd/preferences.dtd">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<map MAP_XML_VERSION="1.0">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '  <entry key="CheckForUpdates" value="false"/>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '</map>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& popd

WORKDIR /home/${USER_NAME}
#+end_src

Sadly this approach does not work because protege dies before the
reasoner prefs file is written.  Therefore we have to run the image
manually and commit before release. Sigh.
#+begin_src dockerfile
# start protege to generate settings files, have to sleep becuase the
# protege sh wrapper breaks $!
RUN \
protege \
& sleep 6 \
&& kill $(ps | grep java | awk '{ printf $1 }')

# on first run protege doesn't check to see if there is already
# something in this prefs.xml file and appends to it automatically
RUN \
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; \
-exec sed -i 's/org.protege.editor.owl.NoOpReasoner/org.semanticweb.elk.elk.reasoner.factory/' {} \;

# must use absolute path otherwise command form won't work
WORKDIR /home/${USER_NAME}
#+end_src

In order to get paths that point to the prefs.xml files that we can
embed in the docker file you need the following commands.
#+begin_src bash
printf '%q' $(find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q CheckForUpdates {} \; -print0)
#+end_src

A useful find command for debugging whether the correct reasoner has been set.
#+begin_src bash
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; -exec cat {} \;
#+end_src

** NIF-Ontology
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:NIF-Ontology
#+end_src

*** build
# TODO progress prints to stderr
#+begin_src bash
docker build \
--tag tgbugs/musl:NIF-Ontology \
--file musl/NIF-Ontology/Dockerfile .
#+end_src

*** file
# FIXME composition with protege user issues I think the right way to
# do this is to move to having a single container user image that we
# build and then use COPY --from on that?
#+name: &musl/NIF-Ontology
#+begin_src dockerfile :tangle ./musl/NIF-Ontology/Dockerfile
FROM tgbugs/musl:protege

# phase three ontology
RUN \
pushd ~/ \
;   mkdir git \
;   pushd git \
;       git clone https://github.com/SciCrunch/NIF-Ontology.git \
;       pushd NIF-Ontology \
;           pushd ttl \
;           cp catalog-v001.xml.example catalog-v001.xml \
;       popd \
;   popd
#+end_src

** neurondm
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:neurondm

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:neurondm \
protege
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:neurondm \
--build-arg ONTOLOGY_GITREF=neurons \
--file musl/neurondm/Dockerfile .
#+end_src

*** file
#+name: &musl/neurondm
#+begin_src dockerfile :tangle ./musl/neurondm/Dockerfile
FROM tgbugs/musl:NIF-Ontology

ARG ONTOLOGY_GITREF=neurons

# phase three ontology
RUN \
pushd ~/git/NIF-Ontology \
;   git checkout ${ONTOLOGY_GITREF} \
;   popd

# phase four python tools
RUN \
pushd ~/ \
;   pushd git \
;       git clone https://github.com/tgbugs/pyontutils.git \
;       pushd pyontutils \
;           pip install --user -e . \
;           pushd neurondm \
;               pip install --user -e . \
;           popd \
;       popd \
;   popd
#+end_src

** npo-1.0
*** run
#+begin_src bash
xhost local:docker

docker pull tgbugs/musl:npo-1.0

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
**** macos notes
#+begin_src bash
brew install virtualbox  # there are some system level persmissions that you will need to set
brew install --cask docker
open -a Docker\ Desktop
# You will need to go to Docker Desktop > Preferences > Resources
# and increase the memory limit to 8 gigs
# otherwise oom killer will end Protege while trying to load npo.ttl

brew install xquartz
open -a XQuartz
# You will need to go to XQuartz > Preferences > Security
# and enable Allow connections from network clients
xhost +localhost
export DISPLAY=:0
# test to make sure everything still works e.g. by running xeyes

docker pull tgbugs/musl:npo-1.0
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=host.docker.internal$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src

Run the block above and once protege starts type =Control R= to run
the reasoner. The docker image is running the Linux version of Protege
so the key bindings use Control instead of Command. You can then run
OWL DL queries in the tab. Note that if you are using the ELK reasoner
(enabled by default in the image) then you will have to click through
a number of warning dialogues, this is normal.

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:npo-1.0 \
--build-arg ONTOLOGY_GITREF=npo-1.0 \
--file musl/neurondm/Dockerfile .
#+end_src

** npo-1.0-neurondm-build
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0-neurondm-build \
sh -c 'git stash && protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
*** build
Build using the SciCrunch SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/npo-1.0-neurondm-build/Dockerfile .
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/npo-1.0-neurondm-build/Dockerfile .
#+end_src
# --build-arg SCIGRAPH_API=http://192.168.1.207:9000/scigraph \

*** file
# FIXME should probably be using a multi source file here instead of
# noweb but I'm not sure we can really do that because the output
# depends on the state of the ontology repo
#+name: &musl/neurondm-build
#+begin_src dockerfile :noweb yes :tangle ./musl/npo-1.0-neurondm-build/Dockerfile
FROM tgbugs/musl:npo-1.0
<<&-base-musl/neurondm-build>>
#+end_src

*** save
This is the image that will be archived to Zenodo for the paper. Note
that the dl queries will not run as expected on this unless you first
stash the changes in =~/git/NIF-Ontology=.

#+begin_src bash
docker save tgbugs/musl:npo-1.0-neurondm-build | gzip > /tmp/npo-1.0-neurondm-build.tar.gz
#+end_src

To restore from the archive run
#+begin_src bash
docker load --input npo-1.0-neurondm-build.tar.gz
#+end_src

The sha256 checksum for npo-1.0-neurondm-build.tar.gz on Zenodo at
doi:10.5281/zenodo.5033493 is
=8e0bb1c684ca8a28f1abeb01ef7aa2597388b8011244f097a92bdd2a523db102=.

** neurondm-build
This image runs the neurondm build process.
*** run
*** build
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/neurondm-build/Dockerfile .
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/neurondm-build/Dockerfile .
#+end_src

*** file
#+name: &musl/neurondm-build
#+begin_src dockerfile :noweb yes :tangle ./musl/neurondm-build/Dockerfile
FROM tgbugs/musl:neurondm
<<&-base-musl/neurondm-build>>
#+end_src

#+name: &-base-musl/neurondm-build
#+begin_src dockerfile
# phase five build
# XXX FIXME we can't run this for the demonstrator because the lack of
# npokb identifiers causes the queries to fail we probably want two
# separate images for this
ARG SCIGRAPH_API
ARG NEURONS_BRANCH
ARG NUID=11741
# FIXME waiting on https://github.com/moby/buildkit/issues/815
#RUN --mount=type=secret,id=scigraph-api-key,uid=${NUID} \
RUN --mount=type=secret,id=scigraph-api-key,uid=1000 source /run/secrets/scigraph-api-key \
; python -m neurondm.models.allen_cell_types \
; python -m neurondm.models.huang2017 \
; python -m neurondm.models.ma2015 \
; git -C ~/git/NIF-Ontology status
#+end_src

** blazegraph
*** run
# TODO release separate images for the data that can be mounted as a volume
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v /var/lib/blazegraph:/var/lib/blazegraph \
-e DISPLAY=$DISPLAY \
-p 9999:9999 \
-it tgbugs/musl:blazegraph
#+end_src

#+begin_src bash
rc-status
touch /run/openrc/softlevel
/etc/init.d/blazegraph start
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:blazegraph \
--file musl/blazegraph/Dockerfile .
#+end_src

*** file
#+name: &musl/blazegraph
#+begin_src dockerfile :tangle ./musl/blazegraph/Dockerfile
FROM tgbugs/musl:icedtea

ARG ARCHIVE
ARG ACCT_GROUP_BLAZEGRAPH_ID=834
ARG ACCT_USER_BLAZEGRAPH_ID="${ACCT_GROUP_BLAZEGRAPH_ID}"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q blazegraph-bin \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** scigraph
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:scigraph
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:scigraph \
--file musl/scigraph/Dockerfile .
#+end_src

*** file
#+name: &musl/scigraph
#+begin_src dockerfile :tangle ./musl/scigraph/Dockerfile
FROM tgbugs/musl:portage-maven AS pm
FROM tgbugs/musl:icedtea

COPY --from=pm / /
# COPY --from=ict / /

ARG ARCHIVE
ARG ACCT_GROUP_SCIGRAPH_ID=835
ARG ACCT_USER_SCIGRAPH_ID="${ACCT_GROUP_SCIGRAPH_ID}"
ARG EGIT_OVERRIDE_REPO_SCIGRAPH_SCIGRAPH=https://github.com/SciCrunch/SciGraph.git
ARG EGIT_OVERRIDE_BRANCH_SCIGRAPH_SCIGRAPH=cypher-execute-fix

#&& echo '*/* -perl -llvm -egl -gles2 -gallium -dbus -vala -introspection -elogind X' >> /etc/portage/package.use/base \
#&& echo '*/* VIDEO_CARDS: -*' >> /etc/portage/package.use/base \
#&& echo 'x11-base/xorg-server minimal xvfb' >> /etc/portage/package.use/base \

#RUN \
#mkdir -p /var/lib/portage/home/.m2 \
#&& echo '<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" #xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' >> /var/lib/portage/home/.m2/settings.xml \
#&& echo '          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 #https://maven.apache.org/xsd/settings-1.0.0.xsd">' >> /var/lib/portage/home/.m2/settings.xml \
#&& echo '<localRepository>/var/tmp/portage/.m2/repository</localRepository>' >> #/var/lib/portage/home/.m2/settings.xml \
#&& echo '</settings>' >> /var/lib/portage/home/.m2/settings.xml \
#&& chown -R portage:portage /var/lib/portage/home/.m2 \
#&& mkdir -p /var/tmp/portage/.m2/repository \
#&& chown -R portage:portage /var/tmp/portage/.m2

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q scigraph-bin --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q scigraph-bin \
;  [[ -n ${ARCHIVE} ]] || { rm -r /var/cache/distfiles/*; rm -r /var/tmp/portage/.m2/repository/*; }

VOLUME /var/db/distfiles
#+end_src

** kg-base
Base environment for knowledge graph distribution and interaction.
Combines both server and client functionalities into a single image.
In principle this could be split into multiple images, but for the
sake of simplicity and reproducibility it is a single image.

*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-base
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-base \
--file musl/kg-base/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-base
#+begin_src dockerfile :noweb yes :tangle ./musl/kg-base/Dockerfile
#FROM tgbugs/musl:blazegraph AS blaze
#FROM tgbugs/musl:scigraph AS scig
#FROM tgbugs/musl:emacs AS em
FROM tgbugs/musl:updated

# FIXME /var/lib/portage/world issues

COPY --from=tgbugs/musl:blazegraph / /
COPY --from=tgbugs/musl:scigraph / /
COPY --from=tgbugs/musl:emacs / /

#COPY --from=blaze / /
#COPY --from=scig / /
#COPY --from=em / /

ARG ARCHIVE

VOLUME /var/db/distfiles
#+end_src

** kg-user
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-user
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-user \
--build-arg KUID=${UID} \
--file musl/kg-user/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-user
#+begin_src dockerfile :tangle ./musl/kg-user/Dockerfile
FROM tgbugs/musl:kg-base

ARG KUID=1000
ARG USER_NAME=kguser

RUN \
groupadd -g ${KUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${KUID} -g ${KUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** kg-dev
*** run
# scigraph-build-local
# scigraph-deploy-local
# TODO package ontree server so that the updated local scigraph can be seen
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev
#+end_src

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v /tmp/scigraph-build:/tmp/scigraph-build \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev \
echo TODO secrets, apinat build and more!
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-dev \
--build-arg AUID=${UID} \
--file musl/kg-dev/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-dev
#+begin_src dockerfile :tangle ./musl/kg-dev/Dockerfile
#FROM tgbugs/musl:python AS py
#FROM tgbugs/musl:emacs AS em
# FROM tgbugs/musl:racket AS rkt
FROM tgbugs/musl:kg-base

#COPY --from=tgbugs/musl:blazegraph / /
#COPY --from=tgbugs/musl:scigraph / /
#COPY --from=tgbugs/musl:emacs / /
COPY --from=tgbugs/musl:racket / /
COPY --from=tgbugs/musl:nodejs / /
COPY --from=tgbugs/musl:pip / /

# COPY --from=rkt / /

ARG ARCHIVE
ARG AUID=1000
ARG USER_NAME=apinatuser

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-arch/zip \
   app-misc/yq \
   dev-python/pyzmq \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN \
groupadd -g ${AUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${AUID} -g ${AUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}

ARG INIT_URL=https://raw.githubusercontent.com/tgbugs/orgstrap/master/init-simple.el

RUN \
emacs --batch --quick --eval "(progn (url-handler-mode 1) (find-file \"${INIT_URL}\") (eval-buffer))"

RUN \
ln -s ~/.emacs.d/reval/cache/*/*-ow.el ~/.emacs.d/ow.el \
&& ln -s ~/.emacs.d/reval/cache/*/*-reval.el ~/.emacs.d/reval.el \
&& ln -s ~/.emacs.d/reval/cache/*/*-init-content.el ~/.emacs.d/init-content.el \
&& echo "(load (concat user-emacs-directory \"ow.el\"))" >> ~/.emacs.d/init.el \
&& echo "(load (concat user-emacs-directory \"reval.el\"))" >> ~/.emacs.d/init.el \
&& echo "(load (concat user-emacs-directory \"init-content.el\"))" >> ~/.emacs.d/init.el

RUN \
mkdir ~/git \
&& mkdir -p ~/.local/bin

RUN \
pushd git \
&&     git clone https://github.com/open-physiology/open-physiology-viewer.git \
&&     pushd open-physiology-viewer \
&&         git fetch origin pull/83/head:pr-83 \
&&         git checkout pr-83 \
&&         npm install \
&&         pushd wrapper \
&&             npm install \
&&         popd \
&&         npm run build \
&&     popd \
&& popd \
&& ln -s ~/git/open-physiology-viewer/wrapper/bin/converter.js ~/.local/bin/apinat-converter

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/pyontutils.git \
&&     pushd pyontutils \
&&         pushd ttlser \
&&             pip install --user -e . \
&&         popd \
&&         pip install --user -e . \
&&         python setup.py --release || true \
&&         pushd nifstd \
&&             pip install --user -e . \
&&             python setup.py --release || true \
&&         popd \
&&     popd \
&& popd

RUN \
pushd git \
&&     git clone https://github.com/SciCrunch/sparc-curation.git \
&&     pushd sparc-curation \
&&         pip install --user -e . \
&&     popd \
&& popd

RUN \
pip install --user git+https://github.com/rdflib/rdflib-jsonld.git

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/idlib.git \
&&     pushd idlib \
&&         pip install --user -e . \
&&     popd \
&& popd

ENV PATH="/home/${USER_NAME}/.local/bin:${PATH}"

VOLUME /var/cache/distfiles
#+end_src

** racket
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:racket \
--file musl/racket/Dockerfile .
#+end_src

Build debug workflow.
#+begin_src bash
# if you have not done so already
docker create \
-v /var/db/repos/gentoo \
--name local-portage-snap \
gentoo/portage:latest \
/bin/true

# if you have you have to clear the container with
# docker rm local-portage-snap

# then
docker run \
--volumes-from local-portage-snap \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket
#+end_src

*** file
#+name: &musl/racket
#+begin_src dockerfile :noweb yes :tangle ./musl/racket/Dockerfile
FROM tgbugs/musl:gtk-no-rust AS gtk-nor
FROM tgbugs/musl:emacs AS em
FROM tgbugs/musl:updated

COPY --from=gtk-nor / /
COPY --from=em / /

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q racket --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -q racket \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

RUN \
eselect racket set cs

VOLUME /var/db/distfiles
#+end_src
** racket-user
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket-user
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:racket-user \
--build-arg RUID=${UID} \
--file musl/racket-user/Dockerfile .
#+end_src

*** file
#+name: &musl/racket-user
#+begin_src dockerfile :tangle ./musl/racket-user/Dockerfile
FROM tgbugs/musl:racket

ARG RUID=1000
ARG USER_NAME=rackuser

RUN \
groupadd -g ${RUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${RUID} -g ${RUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** dynapad-base
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:dynapad-base \
--file musl/dynapad-base/Dockerfile .
#+end_src

*** file
#+name: &musl/dynapad-base
#+begin_src dockerfile :tangle ./musl/dynapad-base/Dockerfile
FROM tgbugs/musl:racket

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-lang/tk \
   sys-libs/db \
   media-gfx/imagemagick \
   app-text/poppler \
   dev-libs/libconfig \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/* 2>&1 > /dev/null || true

VOLUME /var/db/distfiles
#+end_src

** dynapad-user
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:dynapad-user \
--build-arg DUID=${UID} \
--file musl/dynapad-user/Dockerfile .
#+end_src

*** file
#+name: &musl/dynapad-user
#+begin_src dockerfile :tangle ./musl/dynapad-user/Dockerfile
FROM tgbugs/musl:dynapad-base

ARG DUID=1000
ARG USER_NAME=dynapad

RUN \
groupadd -g ${DUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${DUID} -g ${DUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** dynapad
*** run
Once you have created the =tgbugs/musl:dynapad= image (see the build
section below) you can use this command to run it and commit on close
each time so as not to lose any work. You will probably want to mount
any additional directories you will need .e.g for images using =-v=.

**** linux
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src
**** macos
See [[#macos-notes][macos notes]] for notes on getting docker working
with XQuartz.  Assuming everything is set up correctly you can the run
the following.
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=host.docker.internal:0 \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

#+begin_src bash
xattr -d -r -s com.apple.quarantine /Applications/Docker.app
#+end_src

*** build
Since we need to mount the git directory from outside the image we
can't use a docker file. Commit the image after these steps are
finished (the commands above do that automatically).

If your UID is something other than 1000 you will probably want to
rebuild =tgbugs/musl:dynapad-user= so that your UID matches.

#+begin_src bash
docker pull tgbugs/musl:dynapad-user

docker run \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-it tgbugs/musl:dynapad-user
docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

In the image run the following and then exit, the commit will be made
automatically. *NOTE* You may need to remove =build_musl= if it
already exists.
#+begin_src bash
pushd ~/git/dynapad
    mkdir build_musl
    pushd build_musl
        cmake .. -G Ninja
        ninja
    popd
    SUBPATH=$(racketcgc -e "(display (path->string (system-library-subpath)))")
    SO_SUFFIX=$(racketcgc -e "(display (bytes->string/utf-8 (system-type 'so-suffix)))")
    mkdir -p dynapad/compiled/bc/native/${SUBPATH}
    racocgc ctool --cgc \
            ++ldf -Wl,-rpath,"${PWD}/build_musl/" \
            --ld dynapad/compiled/bc/native/${SUBPATH}/libdynapad_rkt${SO_SUFFIX} \
            "${PWD}/build_musl/libdynapad${SO_SUFFIX}"
    racocgc pkg install collects/ dynapad/
    racocgc make apps/paddraw/paddraw.rkt
    racocgc make apps/uberapp/uberapp.rkt
#+end_src

* other
** ubuntu-genera-base
*** file
#+begin_src dockerfile :tangle ./other/ubuntu-genera-base/Dockerfile
FROM ubuntu:18.04

RUN apt update

RUN apt install -y \
curl \
inetutils-inetd \
vim \
telnet \
nfs-common \
nfs-kernel-server \
iproute2 \
libx11-6 \
xserver-xephyr \
x11-xserver-utils \
iputils-ping
#+end_src

*** build
# docker pull ubuntu:18.04
# docker run -it ubuntu:18.04

#+begin_src bash
docker build \
--tag tgbugs/other:ubuntu-genera-base \
--file other/ubuntu-genera-base/Dockerfile .
#+end_src

** genera
A docker file that specifies and image that can run Open Genera 2.0.

We can't distribute the final image for a variety of reasons, however
the configured base image can be distributed and is a valuable
resource as a result.

Useful as a starting point for debugging why it won't work on other systems.

Nearly everything is working except that docker and NFS exports seem
to be fighting with each other.  Old comments on the web mention
issues with exporting overlayfs mounts to NFS, but this commit from
2017 <https://patchwork.kernel.org/project/linux-fsdevel/patch/
1508258671-10800-15-git-send-email-amir73il@gmail.com/> seems to have
fixed that issue.

Three entry points.
https://www.reddit.com/r/lisp/comments/lhsltk/lisp_implementations_similiar_to_old_lisp_machines/
https://gist.github.com/oubiwann/1e7aadfc22e3ae908921aeaccf27e82d
https://archives.loomcom.com/genera/genera-install.html
*** exploration
This will eventually become a docker file, but right now it is still
too experimental so the workflow is run and commit rather than build.

#+begin_src bash
xhost local:docker

# NET_ADMIN apparently needed for tuntap creation (bsd jails and vnets looking really good right now)
# SYS_ADMIN apparently needed to get NFS exports to work (bsd jails looking even better!?)
# generally though this is ok because we are really only using this docker image as a way to get
# an environment where genera will run

docker run -it \
-v ~/files/tmp/genera:/files \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--device /dev/net/tun \
--cap-add NET_ADMIN \
--cap-add SYS_ADMIN \
tgbugs/other:ubuntu-genera-base
#+end_src

In the docker shell (will become the docker file or a script run in the docker file)
#+begin_src bash
#mkdir -p /dev/net
#mknod /dev/net/tun c 10 200

# tunnel creation
# ip tuntap delete dev tap0 mode tap  # to remove since it fights with the host
ip tuntap add dev tap0 mode tap
ip addr add 192.168.2.1/24 dev tap0
ip link set dev tap0 up

# inetd

echo "time      stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "time      dgram   udp  wait   root internal" >> /etc/inetd.conf
echo "daytime   stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "daytime   dgram   udp  wait   root internal" >> /etc/inetd.conf

service inetutils-inetd restart

# retrieve genera files TODO snapshot these to reduce redownload

mkdir genera
pushd genera
curl -LO https://archives.loomcom.com/genera/genera
chmod a+x genera
curl -L -O https://archives.loomcom.com/genera/worlds/Genera-8-5-xlib-patched.vlod
curl -L -O https://archives.loomcom.com/genera/worlds/VLM_debugger
curl -L -O https://archives.loomcom.com/genera/worlds/dot.VLM
mv dot.VLM .VLM
mkdir lib
pushd lib
curl -L -O https://archives.loomcom.com/genera/var_lib_symbolics.tar.gz
tar xvf var_lib_symbolics.tar.gz
chown -R root:root symbolics
ln -s /genera/lib/symbolics /var/lib/symbolics  # may fail
popd

sed -i 's,/home/seth,,' .VLM
echo "192.168.2.1    genera-vlm" >> /etc/hosts
echo "192.168.2.2    genera" >> /etc/hosts

# nfs XXX TODO broken

echo 'RPCNFSDCOUNT="--nfs-version 2 8"' >> /etc/default/nfs-kernel-server
echo 'RPCMOUNTDOPTS="--nfs-version 2 --manage-gids"' >> /etc/default/nfs-kernel-server
echo "/files genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports
# we really want to export / but I'm seeing the following error
# exportfs: / does not support NFS export
#echo "/ genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports

# I think rpcbind needs be be started, otherwise nfs-kernel-server may fail to start
# and/or NFS will not work at all
service rpcbind start

service nfs-kernel-server restart

# start genera using host X server

DISPLAY=:0.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

# start genera using Xephyr (a bit more stable/predictable)

DISPLAY=:0.0; Xephyr -br -reset -terminate -ac -noreset -screen 1280x1024 :3 &
DISPLAY=:3.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

#+end_src
* Bootstrap :noexport:

#+name: orgstrap
#+begin_src elisp :results none :lexical yes
(when noninteractive
  (setq args nil)
  (unless (fboundp #'dockerfile-mode)
    (define-derived-mode dockerfile-mode prog-mode "Dockerfile"
      "Stub to avoid comment-start issues"
      (set (make-local-variable 'comment-start) "#")))
  (org-babel-tangle))
#+end_src

** Local Variables :ARCHIVE:
# close powershell comment #>
# Local Variables:
# eval: (progn (setq-local orgstrap-min-org-version "8.2.10") (let ((actual (org-version)) (need orgstrap-min-org-version)) (or (fboundp #'orgstrap--confirm-eval) (not need) (string< need actual) (string= need actual) (error "Your Org is too old! %s < %s" actual need))) (defun orgstrap-norm-func--prp-1\.1 (body) (let (print-quoted print-length print-level) (prin1-to-string (read (concat "(progn\n" body "\n)"))))) (unless (boundp 'orgstrap-norm-func) (defvar orgstrap-norm-func orgstrap-norm-func-name)) (defun orgstrap-norm-embd (body) (funcall orgstrap-norm-func body)) (unless (fboundp #'orgstrap-norm) (defalias 'orgstrap-norm #'orgstrap-norm-embd)) (defun orgstrap--confirm-eval-minimal (lang body) (not (and (member lang '("elisp" "emacs-lisp")) (eq orgstrap-block-checksum (intern (secure-hash orgstrap-cypher (orgstrap-norm body))))))) (unless (fboundp 'orgstrap--confirm-eval) (defalias 'orgstrap--confirm-eval #'orgstrap--confirm-eval-minimal)) (let ((enable-local-eval nil)) (vc-refresh-state)) (let ((ocbe org-confirm-babel-evaluate) (obs (org-babel-find-named-block "orgstrap"))) (if obs (unwind-protect (save-excursion (setq-local orgstrap-norm-func orgstrap-norm-func-name) (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval) (goto-char obs) (org-babel-execute-src-block)) (setq-local org-confirm-babel-evaluate ocbe) (org-set-startup-visibility)) (warn "No orgstrap block."))))
# End:
