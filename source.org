#+title: Literate source for docker files

#+property: header-args :eval no-export
#+property: header-args:dockerfile :mkdirp yes :comments link :var BUILDKIT_PROGRESS="plain"

* Setup
** Server
Docker files in this repo use buildkit features. To enable it include
the following in [[/etc/docker/daemon.json]].
#+begin_src json :tangle /etc/docker/daemon.json :tangle no
{"experimental": true,
 "features": {"buildkit": true}}
#+end_src

** Client
Building the precursor images in =gentoo/stage3= for this repo from
[[https://github.com/gentoo/gentoo-docker-images][scratch]] requires
the =buildx= extension which requires experimental features to be
enabled in the client.
#+begin_src json :tangle ~/.docker/config.json :tangle no
{"experimental": "enabled"}
#+end_src

* Ops
#+begin_src bash
docker pull gentoo/stage3:amd64-musl-hardened
docker pull gentoo/portage
docker create -v /usr/portage --name local-portage-snap gentoo/portage:latest /bin/true
#+end_src

If you are bootstrapping this file from scratch you will need to build
dependent images in order.

* Next
** TODO a better way
The primary issue here is that it really is not safe to compose after
merge because the power and flexibility of portage happen before
merge, and are quite state dependent after the fact. The key then is
to be able to create images that do compose well, and the only at
the very end materialize them by installing all the packages at once.

The problem is that you give up the utility of the docker layers, but
if we are installing binary packages that have been build on a
separate system then we know that we won't encounter build errors.

The final obstacle to full composability in this way is the issue of
incompatible use flags, but I think it is safe to say that it is not
really possible to solve that problem.

This consideration suggests that the layers of docker images, while
useful, are fundamentally at odds with composability when there are
files inside images that track state (e.g. =/var/lib/portage/world=).

** TODO condense use flags
At the moment we keep use flags with packages and try to keep them
mostly orthogonal to each other. However, at a certain point it is
going to be easier to maintain a single shared use flag image that
will be synchronized across all images. Granular control is nice from
a learning and minimal specification point of view, but from an
engineering an maintenance point of view it is vastly easier easier to
maintain a single shared use flag image that will be synchronized
across all images. Granular control is nice from a learning and
minimal specification point of view, but from an engineering an
maintenance point of view it is simpler to unify the individual image
environments into a single file.
** TODO create an image to build packages
Rebuilding images is wasteful when nothing has changed, and packages
and install properly to maintain the correct state of the image. While
=COPY --from= works, it mangles things like =/var/lib/portage/world=,
and if use flags were changed on a dependency by another source image
then unusual and unexpected errors could occur. This is another reason
to move to manage use flags one or two images, one image for cases
where X11 is not needed, and another where it is.

In fact, I'm fairly certain that having a shared use flag environment
is necessary for it to be possible to safely compose packages and
images. Composition across environments requires something like nix
where each package carries around its own environment. It might be
possible to do better than this by allowing composition in cases where
the environments are compatible, but that would still require
computation at composition time, you can't just layer images an expect
things to work.
** TODO separate user image
Should be able to =COPY --from=tgbugs/musl:user= across all images.
* musl
Pushes to https://hub.docker.com/r/tgbugs/musl. \\
Derived from [[https://hub.docker.com/r/gentoo/stage3/tags?page=1&ordering=last_updated&name=musl-hardened][gentoo/stage3:amd64-musl-hardened]] \\
Further derived from https://ftp-osl.osuosl.org/pub/gentoo/releases/amd64/autobuilds/current-stage3-amd64-musl-hardened/ \\
and from https://gitweb.gentoo.org/proj/releng.git/tree/releases/specs/amd64/musl/stage3-hardened.spec
** updated
*** file
Produce an up-to-date base image for =amd64-hardened-musl= from the
latest stage3 image including the
[[https://github.com/gentoo/musl][musl overlay]] as noted on the
[[https://wiki.gentoo.org/wiki/Project:Hardened_musl#Working_with_musl][wiki]].

At the moment the docker images are generated far more frequently than
the underlying stage3 tarballs are updated, so there are two docker
files, one for building the first time and another for running routine
emerge updates until a new stage3 is released.

Alternately, one way to avoid rebuilds is to build packages and store
them across rebuilds. This will take more work, but ultimately might
be a bit more reproducible since we would avoid the issues with having
an image building =FROM= a prior version of itself.

#+name: &musl/updated
#+begin_src dockerfile :tangle ./musl/updated/Dockerfile
FROM gentoo/stage3:amd64-musl-hardened

ARG ARCHIVE
ARG PYTHON_TARGETS  # use if there are issues with mismatched python targets

RUN \
mkdir /etc/portage/package.accept_keywords \
;  mkdir /etc/portage/package.env \
;  mkdir /etc/portage/package.mask \
;  mkdir /etc/portage/package.unmask \
;  mkdir /etc/portage/package.use \
;  mkdir /etc/portage/repos.conf \
|| echo "fail ok"

RUN \
echo "MAKEOPTS=\"-j$(nproc)\"" >> /etc/portage/make.conf \
&& echo '*/* -perl -gtk -cups -postscript' >> /etc/portage/package.use/00-base \
&& [[ -z ${PYTHON_TARGETS} ]] || \
   echo "*/* PYTHON_TARGETS: -* ${PYTHON_TARGETS}" >> /etc/portage/package.use/00-base \

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-vcs/git \
   eselect-repository \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
mkdir /etc/portage/repos.conf \
&& eselect repository enable musl \
&& emaint sync --repo musl

# exclude gcc during first update since it is slow, it will be updated when running remerge.Dockerfile
RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q -uDN @world \
   --keep-going \
   --exclude sys-devel/gcc \
   --exclude sys-process/procps \
|| echo "something failed to build" \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

#+name: &musl/updated-remerge
#+begin_src dockerfile :tangle ./musl/updated/remerge.Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emaint sync --repo musl \
&& emerge -j4 -q -uDN @world \
   --keep-going \
   --exclude sys-process/procps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:updated \
--file musl/updated/Dockerfile .
#+end_src

*** rebuild
#+begin_src bash
docker build \
--tag tgbugs/musl:updated-remerge \
--file musl/updated/remerge.Dockerfile .

# check that everything works as expected
docker run -it tgbugs/musl:updated-remerge

# rename the image
docker image tag tgbugs/musl:updated-remerge tgbugs/musl:updated
#+end_src

*** refix
Temp fix.
#+begin_src dockerfile :tangle ./musl/updated/remerge-fix.Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN \
mkdir /etc/portage/package.accept_keywords \
;  mkdir /etc/portage/package.env \
;  mkdir /etc/portage/package.mask \
;  mkdir /etc/portage/package.unmask \
;  mkdir /etc/portage/package.use \
;  mkdir /etc/portage/repos.conf \
|| echo "fail ok"

VOLUME /var/cache/distfiles
#+end_src

#+begin_src bash
docker build \
--tag tgbugs/musl:updated-remerge-fix \
--file musl/updated/remerge-fix.Dockerfile .

# check that everything works as expected
docker run -it tgbugs/musl:updated-remerge-fix

# rename the image
docker image tag tgbugs/musl:updated-remerge-fix tgbugs/musl:updated
#+end_src

** TODO use
Modifications to use flags and other system settings and
configurations that are easier to keep in a single location.
*** file
#+begin_src dockerfile :tangle ./musl/use/Dockerfile
# until the new musl allocator is implemented use jemalloc when possible
RUN \
echo '*/* jemalloc' >> /etc/portage/package.use/00-musl
#+end_src
*** nox
#+begin_src dockerfile :tangle ./musl/use/nox.Dockerfile
#+end_src

** portage-maven
Hack to make it possible to install from maven using portage.
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:portage-maven \
--file musl/portage-maven/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/portage-maven/Dockerfile
FROM tgbugs/musl:updated

RUN \
mkdir -p /var/lib/portage/home/.m2 \
&& echo '<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' >> /var/lib/portage/home/.m2/settings.xml \
&& echo '          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd">' >> /var/lib/portage/home/.m2/settings.xml \
&& echo '<localRepository>/var/tmp/portage/.m2/repository</localRepository>' >> /var/lib/portage/home/.m2/settings.xml \
&& echo '</settings>' >> /var/lib/portage/home/.m2/settings.xml \
&& chown -R portage:portage /var/lib/portage/home/.m2 \
&& mkdir -p /var/tmp/portage/.m2/repository \
&& chown -R portage:portage /var/tmp/portage/.m2
#+end_src

** vim
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:vim \
--file musl/vim/Dockerfile .
#+end_src

*** file
#+name: &musl/vim
#+begin_src dockerfile :tangle ./musl/vim/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-editors/vim \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** gdb
If the =nls= or the =python= use flag is set for =gdb= then it will
try to link =libintl_gettext= and fail. Therefore both use flags must
be disabled when building on musl systems at this time. This should
probably be dealt with or fixed in the musl overlay. This might also
be a bug in the =gdb= build since it may need to use =-lintl=.
#+name: &gdb
#+begin_src dockerfile :tangle ./musl/gdb/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN \
echo 'sys-devel/gdb -nls -python' >> /etc/portage/package.use/99-gdb

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   sys-devel/gdb::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

** pip
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:pip \
--file musl/pip/Dockerfile .
#+end_src

*** file
#+name: &musl/pip
#+begin_src dockerfile :tangle ./musl/pip/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-python/pip \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** python
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:python \
--file musl/python/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/python/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q -uDN --keep-going \
   python:3.6 \
   python:3.7 \
   python:3.8 \
   python:3.9 \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN \
echo 'dev-python/pipenv' >> /etc/portage/package.accept_keywords/pipenv

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q pipenv \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** nodejs
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:nodejs \
--file musl/nodejs/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/nodejs/Dockerfile
FROM tgbugs/musl:updated

RUN \
echo 'dev-util/cmake -ncurses' >> /etc/portage/package.use/99-cmake

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   net-libs/nodejs \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** fix fonts
Many other packages pull in freetype, so we have to deal with the
issue before anything else.
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:fix-fonts \
--file musl/fix-fonts/Dockerfile .
#+end_src

*** file
#+name: &fix-fonts
#+begin_src dockerfile :tangle ./musl/fix-fonts/Dockerfile
FROM tgbugs/musl:updated

ARG ARCHIVE

RUN \
echo 'media-libs/freetype -cleartype_hinting -cleartype-hinting' >> /etc/portage/package.use/99-freetype

# rebuild freetype without cleartype hinting
RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q media-libs/freetype \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   fontconfig \
   media-fonts/dejavu \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN \
eselect fontconfig disable 10-hinting-slight.conf \
&& eselect fontconfig enable \
   10-no-sub-pixel.conf \
   57-dejavu-sans.conf \
   57-dejavu-sans-mono.conf

VOLUME /var/cache/distfiles
#+end_src

Only enabling dejavu sans and disabling any and all hinting matters.
There isn't a way to disable antialiasing using the gentoo fontconfig
and even if you do the disabled hinting engine has different and ugly
behavior compared to =-cleartype-hinting= so not sure what is going on
for even further insanity if you enable =10-hinting-none.conf= OR
=10-unhinted.conf= *YOU WILL GET HINTING !?!?!??! WAT!?* or at least
maybe AA is enabled which does not maybe ANY sense. Probably there is
some logic which is that in order to disable some feature there is
some default that is enabled so there winds up being a difference
between there being no reference to a feature and a reference to it to
explicitly disable it. Sigh.

** xorg
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:xorg \
--file musl/xorg/Dockerfile .
#+end_src

# someday when we get babel configured correctly to use comint
# #+call: docker-build-musl(image="xorg")

*** file
#+begin_src dockerfile :tangle ./musl/xorg/Dockerfile
FROM tgbugs/musl:fix-fonts

ARG ARCHIVE

RUN \
echo '*/* VIDEO_CARDS: -*' >> /etc/portage/package.use/20-xorg \
&& echo '*/* -llvm -egl -gles2 -gallium -dbus -vala -introspection -elogind' >> /etc/portage/package.use/20-xorg \
&& echo '*/* X' >> /etc/portage/package.use/20-xorg

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q \
    x11-base/xcb-proto \
    x11-base/xorg-proto \
    x11-libs/libX11 \
    x11-libs/libXau \
    x11-libs/libXdmcp \
    x11-libs/libXext \
    x11-libs/libXfixes \
    x11-libs/libXrender \
    x11-libs/libxcb \
    x11-libs/xtrans \
    x11-misc/compose-tables \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

# needed to ensure that -egl doesn't introduce conflicts
RUN \
echo 'x11-base/xorg-server minimal' >> /etc/portage/package.use/99-xorg-server

VOLUME /var/cache/distfiles
#+end_src

** emacs
Emacs using the athena 3d toolkit to avoid pulling in gtk.
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:emacs
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:emacs \
--file musl/emacs/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/emacs/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN \
echo 'app-editors/emacs dynamic-loading gmp json threads' >> /etc/portage/package.use/99-emacs \
&& echo 'app-editors/emacs gui Xaw3d xft' >> /etc/portage/package.use/99-emacs-gui \
&& echo 'app-emacs/emacs-common gui' >> /etc/portage/package.use/99-emacs-gui

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-editors/emacs \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

** gtk-no-rust
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:gtk-no-rust \
--file musl/gtk-no-rust/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/gtk-no-rust/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN \
echo 'media-libs/freetype harfbuzz' >> /etc/portage/package.use/99-freetype \
&& echo 'dev-util/cmake -ncurses' >> /etc/portage/package.use/99-cmake \
&& echo '=gnome-base/librsvg-2.40.21 **' >> /etc/portage/package.accept_keywords/librsvg \
&& echo '<gnome-base/librsvg-2.41' >> /etc/portage/package.unmask/librsvg \
&& echo '>=gnome-base/librsvg-2.41' >> /etc/portage/package.mask/base \
&& echo '>x11-themes/adwaita-icon-theme-3.33' >> /etc/portage/package.mask/adwaita \
&& echo '>=media-libs/mesa-21' >> /etc/portage/package.mask/mesa

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -1q \
   x11-libs/gtk+ \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

** icedtea
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:icedtea \
--file musl/icedtea/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/icedtea/Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q nss \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q --onlydeps \
   dev-java/icedtea-bin::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-java/icedtea-bin::musl \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

*** legacy
The musl overlay installs icedtea-bin correctly now so this is thankfully no longer needed.
#+name: &musl/icedtea/legacy
#+begin_src dockerfile :tangle ./musl/icedtea/legacy.Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

ARG BASE="https://github.com/tgbugs/musl/releases/download/icedtea-bin-3.18.0-alpine-helper-0/"

ARG TMCH=34581ad0f14b5898abfb8d0a7ad89d560270a2e5

RUN \
eselect repository create local /usr/local/portage

# FIXME this is an evil hack that WILL expire
RUN \
mkdir -p /usr/local/portage/dev-java/icedtea-bin \
&& pushd /usr/local/portage/dev-java/icedtea-bin \
&& ln -s /var/db/repos/musl/dev-java/icedtea-bin/files \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/icedtea-bin-3.18.0.ebuild" \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/Manifest"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q nss \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q dev-java/icedtea-bin::local --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

ARG SIGH="icedtea-bin-3.18.0-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-dbg-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-doc-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-base-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-lib-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-libjpeg-x86_64-musl.tar.gz"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
pushd /var/cache/distfiles \
&& for SI in ${SIGH}; do curl -L -o "${SI}" "${BASE}${SI/-musl/}"; done \
&& popd \
&& emerge -j4 -q dev-java/icedtea-bin::local \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/cache/distfiles
#+end_src

# export failure=$(docker ps -lq)
# docker start $failure
# docker attach $failure

** protege
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:protege \
--build-arg NUID=${UID} \
--file musl/protege/Dockerfile .
#+end_src

Due to the fact that protege needs X11 running in order to create
config files.  Run the following command, change the default reasoner
to ELK, make any other changes that are needed, and then quit protege.
The second command will run automatically and commit the changes.

NOTE you must run the =protege= command manually to prevent the commit
from changing the default behavior of the container from changing its
entry point to run =protege=.

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege && \
docker commit $(docker ps -lq) tgbugs/musl:protege
#+end_src

*** file
We install pip during this step because any builds that =FROM
tgbugs/musl:protege= default to =protegeuser=.
# TODO FIXME we should be able to install protege as root
#+name: &musl/protege
#+begin_src dockerfile :noweb yes :tangle ./musl/protege/Dockerfile
FROM tgbugs/musl:icedtea

ARG ARCHIVE
ARG NUID=11741
ARG USER_NAME=protegeuser
ARG PROTEGE_VERSION="5.5.0"

# phase one build environment
RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-python/pip \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN \
groupadd -g ${NUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${NUID} -g ${NUID} -d /home/${USER_NAME} ${USER_NAME}

VOLUME /var/cache/distfiles

# the rest is run as the neurondm user
USER $USER_NAME

# phase two protege and reasoners
ARG URL_PROTEGE="https://github.com/protegeproject/protege-distribution/releases/download/v5.5.0/Protege-5.5.0-linux.tar.gz"
ARG URL_ELK="https://github.com/liveontologies/elk-reasoner/releases/download/v0.4.3/elk-distribution-0.4.3-protege-plugin.zip"
ARG URL_FACT="https://bitbucket.org/dtsarkov/factplusplus/downloads/uk.ac.manchester.cs.owl.factplusplus-P5.x-v1.6.5.jar"

RUN \
cd ~/ \
&& curl -L -O ${URL_PROTEGE} \
&& tar xvzf Protege-${PROTEGE_VERSION}-linux.tar.gz \
&& pushd Protege-${PROTEGE_VERSION} \
&& rm jre/ -r \
&& sed -i 's/^jre\/bin\/java/\/usr\/bin\/java/' run.sh \
&& sed -i 's/500M/12G/' run.sh \
&& sed -i 's/200M/5G/' run.sh \
&& sed -i 's/16M/160M/' run.sh \
&& pushd plugins \
&& curl -L -O ${URL_FACT} \
&& curl -L -O ${URL_ELK} \
&& unzip -p elk-distribution-0.4.3-protege-plugin.zip \
   elk-distribution-0.4.3-protege-plugin/org.semanticweb.elk.jar \
   > org.semanticweb.elk-0.4.3.jar \
&& rm elk-distribution-0.4.3-protege-plugin.zip \
&& popd; popd \
&& mkdir -p ~/.local/share ~/.local/bin \
&& mv Protege-${PROTEGE_VERSION} ~/.local/share/ \
&& pushd ~/.local/bin \
&& ln -s ~/.local/share/Protege-${PROTEGE_VERSION}/run.sh protege \
&& popd \
&& rm Protege-${PROTEGE_VERSION}-linux.tar.gz

ENV PATH="/home/${USER_NAME}/.local/bin:${PATH}"

# paths to preferences files
ARG PATH_CFU_1=_\!\&\!\!\`g\"\>\!\&@\!\[@\"\(\!%\`\!\|w\"@\!\&\)\!\[@\"\'\!%\`\!\`g\"\&\!%4\!@w\"\&\!\&:=
ARG PATH_CFU_2=_\!\'%\!c\!\"w\!\'w\!a@\"j\!\'%\!d\!\"p\!\'8\!bg\"f\!\(\!\!cg\"l\!\'\}\!~@\"y\!\'\`\!bg\"j\!\'\`\!cw==
ARG PATH_CFU_3=_\!\'8\!cg\"n\!#4\!c\!\"y\!\'8\!d\!\"l\!\'c\!~@\!u\!\'\`\!~\!\"p\!\(@\!bw\"y\!#4\!\}w\"v\!\(\)\!~@\!u\!\(\`\!c\!\"k\!\'%\!d\!\"l\!#4\!\`\!\"s\!\(\`\!~w\"p\!\'4\!\^@\"h\!\'4\!\}@\"n\!\'\`\!cg==
ARG PATH_CFU="${PATH_CFU_1}/${PATH_CFU_2}/${PATH_CFU_3}"

# set preferences so that protege starts in the right state the first time
# protege doesn't create this prefs file by default so we would have to do this regardless
# this helps because it prevents the search for plugins on first run so that goes faster
RUN \
pushd ~/ \
&& mkdir -p ".java/.userPrefs/${PATH_DRI_1}" \
&& chmod 0700 ".java/.userPrefs" \
&& mkdir -p ".java/.userPrefs/${PATH_CFU}" \
&& echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<!DOCTYPE map SYSTEM "http://java.sun.com/dtd/preferences.dtd">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<map MAP_XML_VERSION="1.0">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '  <entry key="CheckForUpdates" value="false"/>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '</map>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& popd

WORKDIR /home/${USER_NAME}
#+end_src

Sadly this approach does not work because protege dies before the
reasoner prefs file is written.  Therefore we have to run the image
manually and commit before release. Sigh.
#+begin_src dockerfile
# start protege to generate settings files, have to sleep becuase the
# protege sh wrapper breaks $!
RUN \
protege \
& sleep 6 \
&& kill $(ps | grep java | awk '{ printf $1 }')

# on first run protege doesn't check to see if there is already
# something in this prefs.xml file and appends to it automatically
RUN \
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; \
-exec sed -i 's/org.protege.editor.owl.NoOpReasoner/org.semanticweb.elk.elk.reasoner.factory/' {} \;

# must use absolute path otherwise command form won't work
WORKDIR /home/${USER_NAME}
#+end_src

In order to get paths that point to the prefs.xml files that we can
embed in the docker file you need the following commands.
#+begin_src bash
printf '%q' $(find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q CheckForUpdates {} \; -print0)
#+end_src

A useful find command for debugging whether the correct reasoner has been set.
#+begin_src bash
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; -exec cat {} \;
#+end_src

** NIF-Ontology
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:NIF-Ontology
#+end_src

*** build
# TODO progress prints to stderr
#+begin_src bash
docker build \
--tag tgbugs/musl:NIF-Ontology \
--file musl/NIF-Ontology/Dockerfile .
#+end_src

*** file
# FIXME composition with protege user issues I think the right way to
# do this is to move to having a single container user image that we
# build and then use COPY --from on that?
#+name: &musl/NIF-Ontology
#+begin_src dockerfile :tangle ./musl/NIF-Ontology/Dockerfile
FROM tgbugs/musl:protege

# phase three ontology
RUN \
pushd ~/ \
;   mkdir git \
;   pushd git \
;       git clone https://github.com/SciCrunch/NIF-Ontology.git \
;       pushd NIF-Ontology \
;           pushd ttl \
;           cp catalog-v001.xml.example catalog-v001.xml \
;       popd \
;   popd
#+end_src

** neurondm
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:neurondm

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:neurondm \
protege
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:neurondm \
--build-arg ONTOLOGY_GITREF=neurons \
--file musl/neurondm/Dockerfile .
#+end_src

*** file
#+name: &musl/neurondm
#+begin_src dockerfile :tangle ./musl/neurondm/Dockerfile
FROM tgbugs/musl:NIF-Ontology

ARG ONTOLOGY_GITREF=neurons

# phase three ontology
RUN \
pushd ~/git/NIF-Ontology \
;   git checkout ${ONTOLOGY_GITREF} \
;   popd

# phase four python tools
RUN \
pushd ~/ \
;   pushd git \
;       git clone https://github.com/tgbugs/pyontutils.git \
;       pushd pyontutils \
;           pip install --user -e . \
;           pushd neurondm \
;               pip install --user -e . \
;           popd \
;       popd \
;   popd
#+end_src

** npo-1.0
*** run
#+begin_src bash
xhost local:docker

docker pull tgbugs/musl:npo-1.0

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
**** macos notes
#+begin_src bash
brew install virtualbox  # there are some system level persmissions that you will need to set
brew install --cask docker
open -a Docker\ Desktop
# You will need to go to Docker Desktop > Preferences > Resources
# and increase the memory limit to 8 gigs
# otherwise oom killer will end Protege while trying to load npo.ttl

brew install xquartz
open -a XQuartz
# You will need to go to XQuartz > Preferences > Security
# and enable Allow connections from network clients
xhost +localhost
export DISPLAY=:0
# test to make sure everything still works e.g. by running xeyes

docker pull tgbugs/musl:npo-1.0
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=host.docker.internal$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src

Run the block above and once protege starts type =Control R= to run
the reasoner. The docker image is running the Linux version of Protege
so the key bindings use Control instead of Command. You can then run
OWL DL queries in the tab. Note that if you are using the ELK reasoner
(enabled by default in the image) then you will have to click through
a number of warning dialogues, this is normal.

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:npo-1.0 \
--build-arg ONTOLOGY_GITREF=npo-1.0 \
--file musl/neurondm/Dockerfile .
#+end_src

** npo-1.0-neurondm-build
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0-neurondm-build \
sh -c 'git stash && protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
*** build
Build using the SciCrunch SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/npo-1.0-neurondm-build/Dockerfile .
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/npo-1.0-neurondm-build/Dockerfile .
#+end_src
# --build-arg SCIGRAPH_API=http://192.168.1.207:9000/scigraph \

*** file
# FIXME should probably be using a multi source file here instead of
# noweb but I'm not sure we can really do that because the output
# depends on the state of the ontology repo
#+name: &musl/neurondm-build
#+begin_src dockerfile :noweb yes :tangle ./musl/npo-1.0-neurondm-build/Dockerfile
FROM tgbugs/musl:npo-1.0
<<&-base-musl/neurondm-build>>
#+end_src

*** save
This is the image that will be archived to Zenodo for the paper. Note
that the dl queries will not run as expected on this unless you first
stash the changes in =~/git/NIF-Ontology=.

#+begin_src bash
docker save tgbugs/musl:npo-1.0-neurondm-build | gzip > /tmp/npo-1.0-neurondm-build.tar.gz
#+end_src

To restore from the archive run
#+begin_src bash
docker load --input npo-1.0-neurondm-build.tar.gz
#+end_src

The sha256 checksum for npo-1.0-neurondm-build.tar.gz on Zenodo at
doi:10.5281/zenodo.5033493 is
=8e0bb1c684ca8a28f1abeb01ef7aa2597388b8011244f097a92bdd2a523db102=.

** neurondm-build
This image runs the neurondm build process.
*** run
*** build
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/neurondm-build/Dockerfile .
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/neurondm-build/Dockerfile .
#+end_src

*** file
#+name: &musl/neurondm-build
#+begin_src dockerfile :noweb yes :tangle ./musl/neurondm-build/Dockerfile
FROM tgbugs/musl:neurondm
<<&-base-musl/neurondm-build>>
#+end_src

#+name: &-base-musl/neurondm-build
#+begin_src dockerfile
# phase five build
# XXX FIXME we can't run this for the demonstrator because the lack of
# npokb identifiers causes the queries to fail we probably want two
# separate images for this
ARG SCIGRAPH_API
ARG NEURONS_BRANCH
ARG NUID=11741
# FIXME waiting on https://github.com/moby/buildkit/issues/815
#RUN --mount=type=secret,id=scigraph-api-key,uid=${NUID} \
RUN --mount=type=secret,id=scigraph-api-key,uid=1000 source /run/secrets/scigraph-api-key \
; python -m neurondm.models.allen_cell_types \
; python -m neurondm.models.huang2017 \
; python -m neurondm.models.ma2015 \
; git -C ~/git/NIF-Ontology status
#+end_src

** blazegraph
*** run
# TODO release separate images for the data that can be mounted as a volume
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v /var/lib/blazegraph:/var/lib/blazegraph \
-e DISPLAY=$DISPLAY \
-p 9999:9999 \
-it tgbugs/musl:blazegraph
#+end_src

#+begin_src bash
rc-status
touch /run/openrc/softlevel
/etc/init.d/blazegraph start
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:blazegraph \
--file musl/blazegraph/Dockerfile .
#+end_src

*** file
#+name: &musl/blazegraph
#+begin_src dockerfile :tangle ./musl/blazegraph/Dockerfile
FROM tgbugs/musl:icedtea

RUN \
eselect repository add tgbugs-overlay git https://github.com/tgbugs/tgbugs-overlay.git \
&& emaint sync --repo tgbugs-overlay

RUN \
echo 'dev-db/blazegraph-bin' >> /etc/portage/package.accept_keywords/blazegraph

ARG ARCHIVE
ARG ACCT_GROUP_BLAZEGRAPH_ID=834
ARG ACCT_USER_BLAZEGRAPH_ID="${ACCT_GROUP_BLAZEGRAPH_ID}"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q blazegraph-bin \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** scigraph
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:scigraph
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:scigraph \
--file musl/scigraph/Dockerfile .
#+end_src

*** file
#+name: &musl/scigraph
#+begin_src dockerfile :tangle ./musl/scigraph/Dockerfile
FROM tgbugs/musl:portage-maven AS pm
FROM tgbugs/musl:icedtea

COPY --from=pm / /
# COPY --from=ict / /

RUN \
eselect repository add tgbugs-overlay git https://github.com/tgbugs/tgbugs-overlay.git \
&& emaint sync --repo tgbugs-overlay

RUN \
echo 'dev-java/scigraph-bin' >> /etc/portage/package.accept_keywords/scigraph \
&& echo 'x11-base/xorg-server xvfb # scigraph' >> /etc/portage/package.use/99-xorg-server

ARG ARCHIVE
ARG ACCT_GROUP_SCIGRAPH_ID=835
ARG ACCT_USER_SCIGRAPH_ID="${ACCT_GROUP_SCIGRAPH_ID}"
ARG EGIT_OVERRIDE_REPO_SCIGRAPH_SCIGRAPH=https://github.com/SciCrunch/SciGraph.git
ARG EGIT_OVERRIDE_BRANCH_SCIGRAPH_SCIGRAPH=cypher-execute-fix

#&& echo '*/* -perl -llvm -egl -gles2 -gallium -dbus -vala -introspection -elogind X' >> /etc/portage/package.use/base \
#&& echo '*/* VIDEO_CARDS: -*' >> /etc/portage/package.use/base \
#&& echo 'x11-base/xorg-server minimal xvfb' >> /etc/portage/package.use/base \

#RUN \
#mkdir -p /var/lib/portage/home/.m2 \
#&& echo '<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" #xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' >> /var/lib/portage/home/.m2/settings.xml \
#&& echo '          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 #https://maven.apache.org/xsd/settings-1.0.0.xsd">' >> /var/lib/portage/home/.m2/settings.xml \
#&& echo '<localRepository>/var/tmp/portage/.m2/repository</localRepository>' >> #/var/lib/portage/home/.m2/settings.xml \
#&& echo '</settings>' >> /var/lib/portage/home/.m2/settings.xml \
#&& chown -R portage:portage /var/lib/portage/home/.m2 \
#&& mkdir -p /var/tmp/portage/.m2/repository \
#&& chown -R portage:portage /var/tmp/portage/.m2

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q scigraph-bin --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q scigraph-bin \
;  [[ -n ${ARCHIVE} ]] || { rm -r /var/cache/distfiles/*; rm -r /var/tmp/portage/.m2/repository/*; }

VOLUME /var/db/distfiles
#+end_src

** kg-base
Base environment for knowledge graph distribution and interaction.
Combines both server and client functionalities into a single image.
In principle this could be split into multiple images, but for the
sake of simplicity and reproducibility it is a single image.

*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-base
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-base \
--file musl/kg-base/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-base
#+begin_src dockerfile :noweb yes :tangle ./musl/kg-base/Dockerfile
#FROM tgbugs/musl:blazegraph AS blaze
#FROM tgbugs/musl:scigraph AS scig
#FROM tgbugs/musl:emacs AS em
FROM tgbugs/musl:updated

# FIXME /var/lib/portage/world issues

COPY --from=tgbugs/musl:blazegraph / /
COPY --from=tgbugs/musl:scigraph / /
COPY --from=tgbugs/musl:emacs / /

#COPY --from=blaze / /
#COPY --from=scig / /
#COPY --from=em / /

ARG ARCHIVE

VOLUME /var/db/distfiles
#+end_src

** kg-user
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-user
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-user \
--build-arg KUID=${UID} \
--file musl/kg-user/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-user
#+begin_src dockerfile :tangle ./musl/kg-user/Dockerfile
FROM tgbugs/musl:kg-base

ARG KUID=1000
ARG USER_NAME=kguser

RUN \
groupadd -g ${KUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${KUID} -g ${KUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** kg-dev
*** run
# scigraph-build-local
# scigraph-deploy-local
# TODO package ontree server so that the updated local scigraph can be seen
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev
#+end_src

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v /tmp/scigraph-build:/tmp/scigraph-build \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev \
echo TODO secrets, apinat build and more!
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:kg-dev \
--build-arg AUID=${UID} \
--file musl/kg-dev/Dockerfile .
#+end_src

*** file
#+name: &musl/kg-dev
#+begin_src dockerfile :tangle ./musl/kg-dev/Dockerfile
#FROM tgbugs/musl:python AS py
#FROM tgbugs/musl:emacs AS em
# FROM tgbugs/musl:racket AS rkt
FROM tgbugs/musl:kg-base

#COPY --from=tgbugs/musl:blazegraph / /
#COPY --from=tgbugs/musl:scigraph / /
#COPY --from=tgbugs/musl:emacs / /
COPY --from=tgbugs/musl:racket / /
COPY --from=tgbugs/musl:nodejs / /
COPY --from=tgbugs/musl:pip / /

# COPY --from=rkt / /

ARG ARCHIVE
ARG AUID=1000
ARG USER_NAME=apinatuser

RUN \
echo 'net-libs/zeromq drafts' >> /etc/portage/package.use/99-zeromq \
&& echo 'app-misc/yq' >> /etc/portage/package.accept_keywords/yq

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   app-arch/zip \
   app-misc/yq \
   dev-python/pyzmq \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN \
groupadd -g ${AUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${AUID} -g ${AUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}

ARG INIT_URL=https://raw.githubusercontent.com/tgbugs/orgstrap/master/init-simple.el

RUN \
emacs --batch --quick --eval "(progn (url-handler-mode 1) (find-file \"${INIT_URL}\") (eval-buffer))"

RUN \
ln -s ~/.emacs.d/reval/cache/*/*-ow.el ~/.emacs.d/ow.el \
&& ln -s ~/.emacs.d/reval/cache/*/*-reval.el ~/.emacs.d/reval.el \
&& ln -s ~/.emacs.d/reval/cache/*/*-init-content.el ~/.emacs.d/init-content.el \
&& echo "(load (concat user-emacs-directory \"ow.el\"))" >> ~/.emacs.d/init.el \
&& echo "(load (concat user-emacs-directory \"reval.el\"))" >> ~/.emacs.d/init.el \
&& echo "(load (concat user-emacs-directory \"init-content.el\"))" >> ~/.emacs.d/init.el

RUN \
mkdir ~/git \
&& mkdir -p ~/.local/bin

RUN \
pushd git \
&&     git clone https://github.com/open-physiology/open-physiology-viewer.git \
&&     pushd open-physiology-viewer \
&&         git fetch origin pull/83/head:pr-83 \
&&         git checkout pr-83 \
&&         npm install \
&&         pushd wrapper \
&&             npm install \
&&         popd \
&&         npm run build \
&&     popd \
&& popd \
&& ln -s ~/git/open-physiology-viewer/wrapper/bin/converter.js ~/.local/bin/apinat-converter

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/pyontutils.git \
&&     pushd pyontutils \
&&         pushd ttlser \
&&             pip install --user -e . \
&&         popd \
&&         pip install --user -e . \
&&         python setup.py --release || true \
&&         pushd nifstd \
&&             pip install --user -e . \
&&             python setup.py --release || true \
&&         popd \
&&     popd \
&& popd

RUN \
pushd git \
&&     git clone https://github.com/SciCrunch/sparc-curation.git \
&&     pushd sparc-curation \
&&         pip install --user -e . \
&&     popd \
&& popd

RUN \
pip install --user git+https://github.com/rdflib/rdflib-jsonld.git

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/idlib.git \
&&     pushd idlib \
&&         pip install --user -e . \
&&     popd \
&& popd

ENV PATH="/home/${USER_NAME}/.local/bin:${PATH}"

VOLUME /var/cache/distfiles
#+end_src

** racket
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:racket \
--file musl/racket/Dockerfile .
#+end_src

Build debug workflow.
#+begin_src bash
# if you have not done so already
docker create \
-v /var/db/repos/gentoo \
--name local-portage-snap \
gentoo/portage:latest \
/bin/true

# if you have you have to clear the container with
# docker rm local-portage-snap

# then
docker run \
--volumes-from local-portage-snap \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket
#+end_src

*** file
#+name: &musl/racket
#+begin_src dockerfile :noweb yes :tangle ./musl/racket/Dockerfile
FROM tgbugs/musl:gtk-no-rust AS gtk-nor
FROM tgbugs/musl:emacs AS em
FROM tgbugs/musl:updated

COPY --from=gtk-nor / /
COPY --from=em / /

RUN \
eselect repository add tgbugs-overlay git https://github.com/tgbugs/tgbugs-overlay.git \
&& emaint sync --repo tgbugs-overlay

RUN \
echo 'dev-scheme/racket cs bc cgc jit' >> /etc/portage/package.use/99-racket \
&& echo 'dev-scheme/racket' >> /etc/portage/package.accept_keywords/racket

ARG ARCHIVE

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q racket --onlydeps \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -q racket \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

RUN \
eselect racket set cs

VOLUME /var/db/distfiles
#+end_src
** racket-user
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket-user
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:racket-user \
--build-arg RUID=${UID} \
--file musl/racket-user/Dockerfile .
#+end_src

*** file
#+name: &musl/racket-user
#+begin_src dockerfile :tangle ./musl/racket-user/Dockerfile
FROM tgbugs/musl:racket

ARG RUID=1000
ARG USER_NAME=rackuser

RUN \
groupadd -g ${RUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${RUID} -g ${RUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** dynapad-base
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:dynapad-base \
--file musl/dynapad-base/Dockerfile .
#+end_src

*** file
#+name: &musl/dynapad-base
#+begin_src dockerfile :tangle ./musl/dynapad-base/Dockerfile
FROM tgbugs/musl:racket

ARG ARCHIVE

RUN \
echo '>=media-gfx/imagemagick-7' >> /etc/portage/package.mask/imagemagick

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   dev-lang/tk \
   sys-libs/db \
   media-gfx/imagemagick \
   app-text/poppler \
   dev-libs/libconfig \
;  [[ -n ${ARCHIVE} ]] || rm -r /var/cache/distfiles/*

VOLUME /var/db/distfiles
#+end_src

** dynapad-user
*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:dynapad-user \
--build-arg DUID=${UID} \
--file musl/dynapad-user/Dockerfile .
#+end_src

*** file
#+name: &musl/dynapad-user
#+begin_src dockerfile :tangle ./musl/dynapad-user/Dockerfile
FROM tgbugs/musl:dynapad-base

ARG DUID=1000
ARG USER_NAME=dynapad

RUN \
groupadd -g ${DUID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${DUID} -g ${DUID} -d /home/${USER_NAME} ${USER_NAME}

USER $USER_NAME

WORKDIR /home/${USER_NAME}
#+end_src

** dynapad
*** run
Once you have created the =tgbugs/musl:dynapad= image (see the build
section below) you can use this command to run it and commit on close
each time so as not to lose any work. You will probably want to mount
any additional directories you will need .e.g for images using =-v=.

**** linux
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src
**** macos
See [[#macos-notes][macos notes]] for notes on getting docker working
with XQuartz.  Assuming everything is set up correctly you can the run
the following.
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=host.docker.internal:0 \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

#+begin_src bash
xattr -d -r -s com.apple.quarantine /Applications/Docker.app
#+end_src

*** build
Since we need to mount the git directory from outside the image we
can't use a docker file. Commit the image after these steps are
finished (the commands above do that automatically).

If your UID is something other than 1000 you will probably want to
rebuild =tgbugs/musl:dynapad-user= so that your UID matches.

#+begin_src bash
docker pull tgbugs/musl:dynapad-user

docker run \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-it tgbugs/musl:dynapad-user
docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

In the image run the following and then exit, the commit will be made
automatically. *NOTE* You may need to remove =build_musl= if it
already exists.
#+begin_src bash
pushd ~/git/dynapad
    mkdir build_musl
    pushd build_musl
        cmake .. -G Ninja
        ninja
    popd
    SUBPATH=$(racketcgc -e "(display (path->string (system-library-subpath)))")
    SO_SUFFIX=$(racketcgc -e "(display (bytes->string/utf-8 (system-type 'so-suffix)))")
    mkdir -p dynapad/compiled/bc/native/${SUBPATH}
    racocgc ctool --cgc \
            ++ldf -Wl,-rpath,"${PWD}/build_musl/" \
            --ld dynapad/compiled/bc/native/${SUBPATH}/libdynapad_rkt${SO_SUFFIX} \
            "${PWD}/build_musl/libdynapad${SO_SUFFIX}"
    racocgc pkg install collects/ dynapad/
    racocgc make apps/paddraw/paddraw.rkt
    racocgc make apps/uberapp/uberapp.rkt
#+end_src

* other
** ubuntu-genera-base
*** file
#+begin_src dockerfile :tangle ./other/ubuntu-genera-base/Dockerfile
FROM ubuntu:18.04

RUN apt update

RUN apt install -y \
curl \
inetutils-inetd \
vim \
telnet \
nfs-common \
nfs-kernel-server \
iproute2 \
libx11-6 \
xserver-xephyr \
x11-xserver-utils \
iputils-ping
#+end_src

*** build
# docker pull ubuntu:18.04
# docker run -it ubuntu:18.04

#+begin_src bash
docker build \
--tag tgbugs/other:ubuntu-genera-base \
--file other/ubuntu-genera-base/Dockerfile .
#+end_src

** genera
A docker file that specifies and image that can run Open Genera 2.0.

We can't distribute the final image for a variety of reasons, however
the configured base image can be distributed and is a valuable
resource as a result.

Useful as a starting point for debugging why it won't work on other systems.

Nearly everything is working except that docker and NFS exports seem
to be fighting with each other.  Old comments on the web mention
issues with exporting overlayfs mounts to NFS, but this commit from
2017 <https://patchwork.kernel.org/project/linux-fsdevel/patch/
1508258671-10800-15-git-send-email-amir73il@gmail.com/> seems to have
fixed that issue.

Three entry points.
https://www.reddit.com/r/lisp/comments/lhsltk/lisp_implementations_similiar_to_old_lisp_machines/
https://gist.github.com/oubiwann/1e7aadfc22e3ae908921aeaccf27e82d
https://archives.loomcom.com/genera/genera-install.html
*** exploration
This will eventually become a docker file, but right now it is still
too experimental so the workflow is run and commit rather than build.

#+begin_src bash
xhost local:docker

# NET_ADMIN apparently needed for tuntap creation (bsd jails and vnets looking really good right now)
# SYS_ADMIN apparently needed to get NFS exports to work (bsd jails looking even better!?)
# generally though this is ok because we are really only using this docker image as a way to get
# an environment where genera will run

docker run -it \
-v ~/files/tmp/genera:/files \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--device /dev/net/tun \
--cap-add NET_ADMIN \
--cap-add SYS_ADMIN \
tgbugs/other:ubuntu-genera-base
#+end_src

In the docker shell (will become the docker file or a script run in the docker file)
#+begin_src bash
#mkdir -p /dev/net
#mknod /dev/net/tun c 10 200

# tunnel creation
# ip tuntap delete dev tap0 mode tap  # to remove since it fights with the host
ip tuntap add dev tap0 mode tap
ip addr add 192.168.2.1/24 dev tap0
ip link set dev tap0 up

# inetd

echo "time      stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "time      dgram   udp  wait   root internal" >> /etc/inetd.conf
echo "daytime   stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "daytime   dgram   udp  wait   root internal" >> /etc/inetd.conf

service inetutils-inetd restart

# retrieve genera files TODO snapshot these to reduce redownload

mkdir genera
pushd genera
curl -LO https://archives.loomcom.com/genera/genera
chmod a+x genera
curl -L -O https://archives.loomcom.com/genera/worlds/Genera-8-5-xlib-patched.vlod
curl -L -O https://archives.loomcom.com/genera/worlds/VLM_debugger
curl -L -O https://archives.loomcom.com/genera/worlds/dot.VLM
mv dot.VLM .VLM
mkdir lib
pushd lib
curl -L -O https://archives.loomcom.com/genera/var_lib_symbolics.tar.gz
tar xvf var_lib_symbolics.tar.gz
chown -R root:root symbolics
ln -s /genera/lib/symbolics /var/lib/symbolics  # may fail
popd

sed -i 's,/home/seth,,' .VLM
echo "192.168.2.1    genera-vlm" >> /etc/hosts
echo "192.168.2.2    genera" >> /etc/hosts

# nfs XXX TODO broken

echo 'RPCNFSDCOUNT="--nfs-version 2 8"' >> /etc/default/nfs-kernel-server
echo 'RPCMOUNTDOPTS="--nfs-version 2 --manage-gids"' >> /etc/default/nfs-kernel-server
echo "/files genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports
# we really want to export / but I'm seeing the following error
# exportfs: / does not support NFS export
#echo "/ genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports

# I think rpcbind needs be be started, otherwise nfs-kernel-server may fail to start
# and/or NFS will not work at all
service rpcbind start

service nfs-kernel-server restart

# start genera using host X server

DISPLAY=:0.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

# start genera using Xephyr (a bit more stable/predictable)

DISPLAY=:0.0; Xephyr -br -reset -terminate -ac -noreset -screen 1280x1024 :3 &
DISPLAY=:3.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

#+end_src
