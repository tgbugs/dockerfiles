# -*- orgstrap-cypher: sha256; orgstrap-norm-func-name: orgstrap-norm-func--prp-1\.1; orgstrap-block-checksum: e260a3ed98153a851097513b6db9ba959320b3e0214dfbf224cda5480979cf73; -*-
# [[orgstrap][jump to the orgstrap block for this file]]
#+title: Literate source for docker files

#+property: header-args :eval no-export
#+property: header-args:bash :var BUILDKIT_PROGRESS="plain"
#+property: header-args:conf :mkdirp yes :noweb yes
#+property: header-args:dockerfile :noweb yes :mkdirp yes :comments link
#+property: header-args:screen :session org-session :cmd sh :noweb yes

#+name: orgstrap-shebang
#+begin_src bash :eval never :results none :exports none
{ __p=$(mktemp -d);touch ${__p}/=;chmod +x ${__p}/=;__op=$PATH;PATH=${__p}:$PATH;} > ${null="/dev/null"}
$file= $MyInvocation.MyCommand.Source
$ErrorActionPreference= "silentlycontinue"
file=$0
args=$@
$ErrorActionPreference= "Continue"
{ PATH=$__op;rm ${__p}/=;rmdir ${__p};} > $null
emacs -batch -no-site-file -eval "(let (vc-follow-symlinks) (defun orgstrap--confirm-eval (l _) (not (memq (intern l) '(elisp emacs-lisp)))) (let ((file (pop argv)) enable-local-variables) (find-file-literally file) (end-of-line) (when (eq (char-before) ?\^m) (let ((coding-system-for-read 'utf-8)) (revert-buffer nil t t)))) (let ((enable-local-eval t) (enable-local-variables :all) (major-mode 'org-mode)) (require 'org) (org-set-regexps-and-options) (hack-local-variables)))" "${file}" -- $args
exit
<# powershell open
#+end_src

* Setup
** Server
Docker files in this repo use buildkit features. To enable it include
the following in [[/etc/docker/daemon.json]].
#+begin_src json :tangle /etc/docker/daemon.json :tangle no
{"experimental": true,
 "features": {"buildkit": true}}
#+end_src

** Client
Building the precursor images in =gentoo/stage3= for this repo from
[[https://github.com/gentoo/gentoo-docker-images][scratch]] requires the =buildx= extension which requires experimental
features to be enabled in the client.

If you want to push the images to a remote docker repository add the
auths section as well (and fill it in with your credentials).
#+begin_src json :tangle ~/.docker/config.json :tangle no
{"experimental": "enabled",
 "auths": {
   "https://index.docker.io/v1/": {
     "auth": "XXX NOT A REAL KEY FILL ME IN XXX"}}}
#+end_src

** Package host
Prepare package host folders. The server will be started automatically
below if it is not already up.
#+begin_src screen
mkdir -p ~/files/binpkgs/multi
#+end_src
*** prepare all binpkg repos
We have to prepare all the binpkg repos so that during a first build
they have some basic metadata, otherwise trying to emerge binpkgs will
fail with strange errors in strange ways.
#+name: &run-quickpkg-first-time
#+begin_src screen
for stage3 in {hardened,amd64-musl-hardened}; do
    docker pull gentoo/stage3:${stage3}
    docker run \
    -v ~/files/binpkgs/multi:/var/cache/binpkgs \
    -e FEATURES=binpkg-multi-instance \
    -e QUICKPKG_DEFAULT_OPTS="--include-unmodified-config=y --umask=022" \
    --rm \
    gentoo/stage3:${stage3} \
    quickpkg "virtual/ssh";
done
#+end_src

** Portage git ssh access
Needed for live ebuilds that point to private git repos.
Eventually this should be baked into the docker in docker top level image.

You will need to generate ssh keys for the host system if they do not
already exist, and you will need to register them with the git remote.

This is similar to what we do for [[*portage-maven][portage-maven]].

The default location for the portage home directory is now
=/var/lib/portage/home/.ssh= which means that the ssh config and
private keys can be stored there persistently and safely without
violating the sandbox during package fetch.

In the even that you have to deal with some strange legacy case you
may want to symlink a path outside the sandbox to a path inside the
sandbox due to the change in home directory from =/var/tmp/portage= ->
=/var/lib/portage/home=. Inside the images we have to run
=ln -s /var/tmp/portage/.ssh /var/lib/portage/home/.ssh=.

If =/var/tmp/portage= is still the portage home folder and it is a
ramdisk that is wiped on reboot you will want the following.
#+begin_src bash :tangle /su::/etc/local.d/20portage-symlinks.start :tangle-mode 0755 :tangle no
# relink .ssh across restarts
ln -s /mnt/str/portage/.ssh /var/tmp/portage/
chown -h portage:portage /var/tmp/portage/.ssh
#+end_src

* Ops
** Build
If you are bootstrapping this file from scratch you will need to build
dependent images in order.

To prepare a fresh cycle of images.
# FIXME something is off when trying to bootstrap this from scratch on a new computer
# things break at ref:&musl-build-xorg
#+name: workflow
#+begin_src screen
<<&workflow-funs>>

unset _refresh _repos _repackage _resnap _live_rebuild _nopkgbldr
_refresh=
_repos=
_repackage=
_resnap=
_live_rebuild=
_nopkgbldr=
package-server
pull
pushd ~/git/dockerfiles
tangle &&
run-musl
# package host
# build a bunch of packages
popd
#+end_src
# reminder that closing parens must be on separate lines or terminate with ;
# XXX ob-screen doesn't support :var right now
# #+header: :var _refresh=(or workflow-refresh) _repos=(or workflow-refresh workflow-repos)
#+name: &workflow-funs
#+begin_src screen
function package-server () {
# FIXME needs to run in another terminal, container, or daemon
# but for now it blocks other commands which is ok
curl --fail --head http://localhost:8089/musl/Packages || {
    pushd ~/files/binpkgs
    python -m http.server 8089 --bind 127.0.0.1
    popd
}
}

function pull () {
if [ -n "${_refresh}" ]; then
    docker pull gentoo/stage3:amd64-musl-hardened
fi

if [ -n "${_refresh}" ] || [ -n "${_repos}" ]; then
    docker pull gentoo/portage:latest
    docker rm local-portage-snap
    docker create -v /var/db/repos/gentoo --name local-portage-snap gentoo/portage:latest /bin/true
fi
}

function tangle () {
[ -d ./docker-profile ] && rm -r ./docker-profile
[ -d ./gnu ] && rm -r ./gnu
[ -d ./musl ] && rm -r ./musl
[ -d ./repos ] && rm -r ./repos
./source.org --tangle  # TODO --tangle does nothing right now because the behavior is default
return $?
}

function run-gnu () {
echo TODO
}

<<&container-check>>

<<&builder-resnap>>

<<&builder-world>>

<<&builder-arb>>

<<&builder-debug>>

function run-musl () {
local REPOS="${_repos}"
# TODO set QPKG below based on whether any new packages were actually built
local QPKG="${_repackage}"
local QPKGX="${_repackage}"
local QPKGSX="${_repackage}"
local RESNAP="${_resnap}"
local LIVE_REBUILD="${_live_rebuild}"
local NOBUILD="${_nopkgbldr}"
<<&musl-build-user>> || return $?;
<<&musl-build-portage-maven>> || return $?;
<<&musl-build-profile>> || return $?;
<<&musl-build-profile-x>> || return $?;
<<&musl-build-profile-nox>> || return $?;
<<&musl-build-profile-static-x>> || return $?;
  <<&musl-build-eselect-repo>> || return $?;
    [ -z $REPOS ] || {
    <<&repos-build-repos>> || return $?;
    docker container inspect local-repos-snap > /dev/null &&
    docker rm local-repos-snap;
    docker create -v /var/db/repos --name local-repos-snap tgbugs/repos:latest /bin/true || return $?;
    }
    <<&musl-build-updated>> || return $?; echo mbu;
      <<&musl-build-updated-user>> || return $?; echo mbuu;
      # FIXME quickpkg should not repackage
      [ -z $QPKG ] ||
      <<&musl-run-updated-quickpkg>> || return $?; echo mruq;

      <<&musl-build-package-builder-nox>> || return $?; echo mbpbn;
      <<&musl-build-binpkg-only-nox>> || return $?; echo mbbon;

      # XXX this is the point at which things split into musl and musl/x
      <<&musl-build-xorg>> || return $?; echo mbx;
      # FIXME quickpkg should not repackage
      [ -z $QPKGX ] ||
      <<&musl-run-xorg-quickpkg>> || return $?; echo mrxq;

      <<&musl-build-package-builder>> || return $?; echo mbpb;
      <<&musl-build-binpkg-only>> || return $?; echo mbpo;

      # XXX split to musl/static/x
      <<&musl-build-static-xorg>> || return $?; echo mbsx;
      [ -z $QPKGSX ] ||
      <<&musl-run-static-xorg-quickpkg>> || return $?; echo mrsxp;

      <<&musl-build-static-package-builder>> || return $?; echo mbspb;
      <<&musl-build-static-binpkg-only>> || return $?; echo mbsbo;


# TODO build any new packages
[ -z $RESNAP ] || builder-resnap
[ ! -z $NOBUILD ] || builder-world
# TODO smart-live-rebuild
[ -z $LIVE_REBUILD ] || builder-arb @live-rebuild

[ -z $RESNAP ] || static-builder-resnap
[ ! -z $NOBUILD ] || static-builder-world  # FIXME if this is not run once at the start then something fails above
[ -z $LIVE_REBUILD ] || static-builder-arb @live-rebuild

# TODO consider whether we need to rebuild baselayout openrc sgml-common due to config issues with quickpkg

# image builds

## emacs
<<&musl-build-emacs>> || return $?; echo mbe;  # XXX fail on stale profile is very confusing

## kg
<<&musl-build-kg-release>> || return $?; echo mbkgr;
<<&musl-build-kg-release-user>> || return $?; echo mbkgru;
<<&musl-build-kg-dev>> || return $?; echo mbkgd;
<<&musl-build-kg-dev-user>> || return $?; echo mbkgdu;

## sbcl
<<&musl-build-sbcl>> || return $?; echo mbsbcl;
<<&musl-build-sbcl-user>> || return $?; echo mbsbclu;

## racket
<<&musl-build-racket>> || return $?; echo mbrac;
<<&musl-build-racket-user>> || return $?; echo mbracu;

## dynapad
<<&musl-build-dynapad-base>> || return $?; echo mbdb;
<<&musl-build-dynapad-user>> || return $?; echo mbdbu;
#<<&musl-build-dynapad>> || return $?; # needs to be done by hand

## NIF-ontology
<<&musl-build-icedtea>> || return $?; echo mbicdt;
<<&musl-build-protege>> || return $?; echo mbp;
<<&musl-build-NIF-ontology>> || return $?; echo mbno;

## interlex
<<&musl-build-interlex>> || return $?; echo mbilx;

}
#+end_src

# I am an idiot, the repos image is being build incorrectly and pulls
# in the local images so it overrides. DUH.

#+begin_src screen
<<&musl-run-updated-user>>
#+end_src
** Debug build
Sometimes a build will fail.
As long as you aren't using buildkit features such as mount you can
rerun a build command with ~DOCKER_BUILDKIT=0~ prepended which will
keep the intermediate containers around so you can attach to the last
known good layer and try to run things yourself.

Alternately, it may be a better approach to simply truncate the docker
file directly after the last known good step

** Push
To push the latest cycle of images to the default remote run the
following after checking that they work as expected.

#+begin_src bash
for _image in $(docker images --filter=reference="tgbugs/musl:*" --filter=reference="tgbugs/repos:*" --filter=since='tgbugs/musl:eselect-repo' --format "{{.Repository}}:{{.Tag}}" | grep -v snap); do
    docker push "${_image}"
done
#+end_src

** Emergency quickpkg
Sometimes you don't want to wait to get to the package builder step
because there is some bug in between.
#+name: &docker-quickpkg
#+begin_src bash
function docker-quickpkg () {
# FIXME TODO pass the image to package
docker run \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-e FEATURES=binpkg-multi-instance \
-e QUICKPKG_DEFAULT_OPTS="--include-unmodified-config=y --umask=022" \
--rm \
tgbugs/musl:static-xorg \
quickpkg \
${@}
}
#+end_src
* Next
** TODO update package builder image setup to accommodate /etc/portage/patches
pypy3 is an example of one case where we need a fix, but in general
=/etc/portage/patches= is a way to rapidly build and deploy fixes
without having to wait for e.g. a full pull request cycle to finish.
** DONE catch errors in profile early
** TODO dind or similar for top level ops
Docker is not homogeneous with regard to nesting containers since the
way that we use it is a bit outside the usual use case (and because
docker is a hack and true nesting reveals this by violating a whole
bunch of assumptions that are baked into the implementation).

As a result, a hack is required to be able to fake nesting. In this
case the simplest approach seems to be to make the ur-host's docker
process accessible to the top level ops container. Not truly
homogeneous, but better than nothing. This is done by mounting the
socket for the docker daemon when you run the top level build image.

Since this is a build process security considerations are identical
for the true host and the top level image. If we weren't running in
the top level image we would be running on the true host directly so
sandboxing is irrelevant.

An example approach would be to run something like the following.
#+begin_src bash
docker run -v /var/run/docker.sock:/var/run/docker.sock tgbugs/musl:docker
#+end_src

** DONE a better way
The primary issue here is that it really is not safe to compose after
merge because the power and flexibility of portage happen before
merge, and are quite state dependent after the fact. The key then is
to be able to create images that do compose well, and the only at
the very end materialize them by installing all the packages at once.

The problem is that you give up the utility of the docker layers, but
if we are installing binary packages that have been built on a
separate system then we know that we won't encounter build errors.

The final obstacle to full composability in this way is the issue of
incompatible use flags, but I think it is safe to say that it is not
really possible to solve that problem.

This consideration suggests that the layers of docker images, while
useful, are fundamentally at odds with composability when there are
files inside images that track state (e.g. =/var/lib/portage/world=).

** DONE condense use flags
At the moment we keep use flags with packages and try to keep them
mostly orthogonal to each other. However, at a certain point it is
going to be easier to maintain a single shared use flag image that
will be synchronized across all images. Granular control is nice from
a learning and minimal specification point of view, but from an
engineering an maintenance point of view it is vastly easier easier to
maintain a single shared use flag image that will be synchronized
across all images. Granular control is nice from a learning and
minimal specification point of view, but from an engineering an
maintenance point of view it is simpler to unify the individual image
environments into a single file.
** DONE create an image to build packages
Rebuilding images is wasteful when nothing has changed, and packages
and install properly to maintain the correct state of the image. While
=COPY --from= works, it mangles things like =/var/lib/portage/world=,
and if use flags were changed on a dependency by another source image
then unusual and unexpected errors could occur. This is another reason
to move to manage use flags one or two images, one image for cases
where X11 is not needed, and another where it is.

In fact, I'm fairly certain that having a shared use flag environment
is necessary for it to be possible to safely compose packages and
images. Composition across environments requires something like nix
where each package carries around its own environment. It might be
possible to do better than this by allowing composition in cases where
the environments are compatible, but that would still require
computation at composition time, you can't just layer images an expect
things to work.

alternately mount =/var/cache/binpkgs= and then run quickpkg or
something devious like that
** TODO separate user image
Should be able to =COPY --from=tgbugs/musl:user= across all images.
build the user image from a base that has next to nothing in it
add the user and group to the system and then copy that minimal
user stuff in, most of the time there isn't any fancy installation
that needed to be done, and we could just copy the user directory
when building from scratch
* docker-profile
** base
The right way to do this is to create two custom profiles on top of musl-hardened.

https://wiki.gentoo.org/wiki/Profile_(Portage)#custom

Modifications to use flags and other system settings and
configurations that are easier to keep in a single location.
# FIXME this may need to be versioned, or we just force rebuild on all
# the images from scratch which we often have to do anyway, though some
# packages may not be affect by profile changes
*** build
#+name: &docker-profile-build-base
#+begin_src screen
docker build \
--tag tgbugs/docker-profile:base \
--file docker-profile/base/Dockerfile docker-profile/base
#+end_src

*** file
#+begin_src dockerfile :tangle ./docker-profile/base/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

# we don't put this in var/db/repos because repos is managed via tgbugs/repos:latest
ADD docker-profile var/db/docker-profile
ADD docker-profile.conf etc/portage/repos.conf/docker-profile.conf
ADD package.accept_keywords etc/portage/package.accept_keywords/profile
ADD package.mask etc/portage/package.mask/profile

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** etc
**** repos.conf
#+begin_src conf :tangle ./docker-profile/base/docker-profile.conf
[docker-profile]
location = /var/db/docker-profile
#+end_src
**** binrepos.conf
#+begin_src conf :tangle ./docker-profile/base/binrepos-multi.conf
[tgbugs-multi]
priority = 100
sync-uri = http://local.binhost:8089/multi
#+end_src
**** package.accept_keywords
#+begin_src conf :tangle ./docker-profile/base/package.accept_keywords
dev-python/*::tgbugs-overlay
dev-scheme/racket::tgbugs-overlay
#+end_src
**** package.mask
#+begin_src conf :tangle ./docker-profile/base/package.mask
dev-scheme/racket::gentoo
#+end_src
*** profiles
#+begin_src conf :tangle ./docker-profile/base/docker-profile/metadata/layout.conf
masters = gentoo
profile-formats = portage-2
#+end_src

#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/repo_name
docker-profile
#+end_src

# NOTE that tgbugs/musl/x is listed here but not populated until later
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/profiles.desc
amd64 tgbugs               dev
amd64 tgbugs/x             dev
amd64 tgbugs/gnu           dev
amd64 tgbugs/gnu/x         dev
amd64 tgbugs/musl          dev
amd64 tgbugs/musl/x        dev
amd64 tgbugs/musl/static   dev
amd64 tgbugs/musl/static/x dev
#+end_src
**** packages
Useful to keep these out of file:/var/lib/portage/world so that individual
docker files can just =ADD= their world file and then =emerge @world=. It
also makes it much easier for the package builder to operate based on world files.
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/packages
*dev-vcs/git
*app-eselect/eselect-repository
#+end_src
**** make.defaults
# old, we use INSTALL_MASK for simplicity
#+begin_comment
See warning about https://wiki.gentoo.org/wiki/Localization/Guide#LINGUAS.
We are safe here because this base profile is shared between all our
systems and because we do not redistribute the binary packages.

We restrict =LINGUAS= here to reduce the size of the images that are
produced.  Larger images with localization enabled can be produced by
removing the restriction, but are not included by default. This
approach is likely better than using =INSTALL_MASK=.
#+end_comment

# USE="-doc"
# LINGUAS="en"
# for some reason empty video cards does not actually disable all the flags
Normally we don't set =USE== in make.conf, however there is no way to set
global use flags in a profile without doing so.
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/make.defaults
INSTALL_MASK="${INSTALL_MASK}
/usr/share/locale
-/usr/share/locale/en
-/usr/share/locale/en@boldquot
-/usr/share/locale/en@quot
-/usr/share/locale/en@shaw
-/usr/share/locale/en_US"

# icu is needed due to musl collation issues
# jemalloc can improve performance re issues with musl allocator
USE="${USE} icu jemalloc"

VIDEO_CARDS="-*"

# ensure that packages are readable by other users via umask 022
# use unmodified config in case a config file is modified, configs
# should never wind up modified when using package builder images
# see https://bugs.gentoo.org/307455 for more
# FIXME XXX current issues include
# /etc/hosts -> sys-apps/baselayout
# /etc/rc.conf -> sys-apps/openrc
# /etc/sgml/catalog -> app-text/sgml-common
# which seem to have been modified by other merges
QUICKPKG_DEFAULT_OPTS="--include-unmodified-config=y --umask=022"

ACCT_GROUP_BLAZEGRAPH_ID=834
ACCT_USER_BLAZEGRAPH_ID="${ACCT_GROUP_BLAZEGRAPH_ID}"

ACCT_GROUP_SCIGRAPH_ID=835
ACCT_USER_SCIGRAPH_ID="${ACCT_GROUP_SCIGRAPH_ID}"

ACCT_GROUP_SPARC_ID=836
ACCT_USER_SPARC_ID="${ACCT_GROUP_SPARC_ID}"

ACCT_GROUP_PROTCUR_ID=837
ACCT_USER_PROTCUR_ID="${ACCT_GROUP_PROTCUR_ID}"

ACCT_GROUP_SCIBOT_ID=838
ACCT_USER_SCIBOT_ID="${ACCT_GROUP_SCIBOT_ID}"

ACCT_GROUP_INTERLEX_ID=839
ACCT_USER_INTERLEX_ID="${ACCT_GROUP_INTERLEX_ID}"

ACCT_GROUP_NIFSTD_TOOLS_ID=840
ACCT_USER_NIFSTD_TOOLS_ID="${ACCT_GROUP_NIFSTD_TOOLS_ID}"

ACCT_GROUP_METABASE_ID=841
ACCT_USER_METABASE_ID="${ACCT_GROUP_METABASE_ID}"

EGIT_OVERRIDE_REPO_SCIGRAPH_SCIGRAPH=https://github.com/SciCrunch/SciGraph.git
EGIT_OVERRIDE_BRANCH_SCIGRAPH_SCIGRAPH=cypher-execute-fix
#+end_src

# FIXME the ACCT_ and EGIT_OVERRIDE_ should probably be in env, but we rebuild
# this profile so frequently I think putting it in make.defaults is probably ok

**** mask
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/package.mask
# insurance
dev-lang/rust
dev-lang/rust-bin

# gtknor
>=gnome-base/librsvg-2.41
>x11-themes/adwaita-icon-theme-3.33

# dynapad
>=media-gfx/imagemagick-7
#+end_src
**** unmask
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/package.unmask
# gtknor
<gnome-base/librsvg-2.41
#+end_src
**** accept_keywords
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/package.accept_keywords
dev-python/pipenv ~amd64
app-misc/yq ~amd64

# harfbuzz 3.1.2 needs freetype-2.11.1 otherwise build fails
=media-libs/freetype-2.11.1 ~amd64

# tgbugs-overlay
dev-db/blazegraph-bin ~amd64
dev-java/robot-bin ~amd64
dev-java/scigraph-bin ~amd64
#dev-scheme/racket ~amd64  # profile can't restrict by repo :(

# tgbugs-overlay python
dev-python/interlex **

# gtknor
<gnome-base/librsvg-2.41 **

# emacs
app-emacs/vterm ~amd64

# sbcl
dev-lisp/asdf ~amd64
dev-lisp/uiop ~amd64
dev-lisp/sbcl ~amd64

# python packaging chaos
dev-python/setuptools ~amd64  # TODO remove this when upstream shifts
#+end_src
# probably have to put dev-python/*::tgbugs-overlay in /etc/portage/package.accept_keywords/profile
# dev-python/pyontutils ~amd64
# XXX if we introduce pypy3 this is going to be a mess

# interesting issue with dev-python/interlex ** nominally being completely
# irrelevant and orthognal to the rest of the contstraints on other images
# that will never install it, it technically triggers a rebuild of everything
# because we make the profile a dependency, we mitigate this by using binpkgs
# but really we should be able to put things like this in the package builder
# image and snapshot and then only in the docker files that will actually
# install that package itself ... hrm ... unfortunately that is WAY harder
# for someone to understand and track than it is to stick it in here and
# rebuild everything ... sigh, eventually we will implement this optimization
**** package.use
# TODO consider dev-db/sqlite secure-delete
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/package.use
# font rendering
media-libs/freetype -cleartype-hinting -cleartype_hinting

# needed to ensure that -egl doesn't introduce conflicts
x11-base/xorg-server minimal

app-editors/emacs dynamic-loading gmp json threads

# gdb don't pull in the world
sys-devel/gdb -nls -python

# pyzmq
net-libs/zeromq drafts

dev-scheme/racket cs bc cgc jit

# graphviz
media-libs/gd truetype fontconfig

# tgbugs-overlay python
dev-python/orthauth yaml  # FIXME sxpyr ftlog
#+end_src

**** use.mask
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/use.mask
# reduce deps
perl
gtk
cups
postscript

# reduce xorg deps
llvm
egl
gles2
gallium
dbus
vala
introspection
elogind
#+end_src
**** x/
intentionally empty
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/x/parent
..
#+end_src
**** nox/
intentionally empty
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/nox/parent
..
#+end_src
**** gnu/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/gnu/parent
gentoo:default/linux/amd64/17.1/hardened
..
#+end_src
**** gnu/x/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/gnu/x/parent
..
../../x
#+end_src
**** gnu/nox/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/gnu/nox/parent
..
../../nox
#+end_src
**** musl/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/parent
gentoo:default/linux/amd64/17.0/musl/hardened
..
#+end_src
**** musl/x/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/x/parent
..
../../x
#+end_src
**** musl/nox/
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/nox/parent
..
../../nox
#+end_src
**** musl/static
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/static/parent
..
#+end_src
**** musl/static/x
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/static/x/parent
..
../../../x
#+end_src
**** musl/static/nox
***** parent
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/musl/static/nox/parent
..
../../../nox
#+end_src
** static
*** profiles
***** make.defaults
We only set =static-libs= not =static= because =static= statically
links the executable which we rarely want, in which case a positive
static use flag should be added below, rather than turning off nearly
every instance of =static= that we encounter.
#+begin_src conf :tangle ./docker-profile/static/docker-profile/profiles/tgbugs/musl/static/make.defaults
USE="static-libs"
#+end_src
***** package.use :ARCHIVE:
#+begin_src conf :tangle ./docker-profile/static/docker-profile/profiles/tgbugs/musl/static/package.use :tangle no
# don't build openssh with static libs because it conflicts with the
# pie use flag for hardened which cannot be unset
net-misc/openssh -static

# bzip2 is completely broken if compiled with either of these use flags ???
# that is, it will compile but will leave the system unable to compress anything
app-arch/bzip2 -static

# trying to build with static causes a configure error due to container projections
# building with security=insecure supposedly can work around this
# cross compile check process_vm_readv # ccc process_vm_readv
# FIXME, further reading seems to suggest that we don't actually want static? just
# static-libs? so going to try that
app-arch/gzip -static
sys-apps/debianutils -static
sys-apps/coreutils -static
sys-devel/patch -static
sys-apps/findutils -static
sys-apps/sed -static
sys-devel/make -static
net-misc/wget -static
sys-apps/diffutils -static
sys-apps/grep -static
app-editors/nano -static
sys-devel/flex -static
sys-devel/bison -static
#+end_src

#+begin_src bash
echo \
sys-devel/bison \
-static >> /etc/portage/package.use/sigh && \
emerge -uDN @world
#+end_src
** x
*** profiles
**** parent
#+begin_src conf :tangle ./docker-profile/x/docker-profile/profiles/tgbugs/x/parent
..
#+end_src
**** packages
#+begin_src conf :tangle ./docker-profile/x/docker-profile/profiles/tgbugs/x/packages
*media-fonts/dejavu
*media-libs/fontconfig
*media-libs/freetype
#+end_src
**** make.defaults
#+begin_src conf :tangle ./docker-profile/base/docker-profile/profiles/tgbugs/x/make.defaults
USE="X"
VIDEO_CARDS="-*"
#+end_src
**** package.use
# we might consider including svg and libxml2 because they are already pulled in by racket and some other components
# app-editors/emacs libxml2 svg
#+begin_src conf :tangle ./docker-profile/x/docker-profile/profiles/tgbugs/x/package.use
# ,*/* X # FIXME it seems that wildcards are not allowed in here so for now has to be done later

media-libs/freetype harfbuzz

# the mesa ebuilds in the main tree are missing the fact that
# gbm expects egl to be enabled, if it is not build errors
media-libs/mesa -gbm

app-editors/emacs gui Xaw3d xft # XXX note that latest reccomendations are to use harfbuzz + cairo for text shaping (or something like that)
app-emacs/emacs-common gui

# avoid extra deps
dev-util/cmake -ncurses

# scigraph
x11-base/xorg-server xvfb
#+end_src

**** mask
The media-libs/mesa-21.1 set fails to build even with all the use flags set correctly.
Same issue with media-libs/mesa-21.1 https://bugs.gentoo.org/828491. Currently 21.2.6
is the only one that will compile correctly.
#+begin_src conf :tangle ./docker-profile/x/docker-profile/profiles/tgbugs/x/package.mask
<media-libs/mesa-21.2
>=media-libs/mesa-21.3
#+end_src
**** accept_keywords
#+begin_src conf :tangle ./docker-profile/x/docker-profile/profiles/tgbugs/x/package.accept_keywords
#+end_src
** nox
Explicit nox profile.
*** build
#+name: &musl-build-profile-nox
#+begin_src screen
docker build \
--tag tgbugs/musl:profile-nox \
--file docker-profile/nox/Dockerfile docker-profile/nox
#+end_src

*** file
#+begin_src dockerfile :tangle ./docker-profile/nox/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD docker-profile var/db/docker-profile

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** profiles
**** parent
#+begin_src conf :tangle ./docker-profile/nox/docker-profile/profiles/tgbugs/nox/parent
..
#+end_src

**** package.use
#+begin_src conf :tangle ./docker-profile/nox/docker-profile/profiles/tgbugs/nox/package.use
dev-java/icedtea headless-awt
#+end_src

* repos
Overlays can take up quite a bit of space so it is better to mount
them the same way we mount the gentoo repo during build so that we can
keep the images a bit slimmer. We can publish the build images
independently, and it is also worth noting that from a reproducibility
perspective the exact ebuilds are stored in file:/var/db/pkg/.
*** build
#+name: &repos-build-repos
#+begin_src screen
docker build \
--no-cache \
--tag tgbugs/repos:latest \
--file repos/Dockerfile repos
#+end_src
*** file
#+begin_src dockerfile :tangle ./repos/Dockerfile
FROM tgbugs/musl:eselect-repo as builder

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
   emaint sync --repo musl \
&& emaint sync --repo lisp \
&& emaint sync --repo tgbugs-overlay \
&& rm -r /var/db/repos/lisp/dev-scheme/racket

# emergency backup
ARG BASE="https://github.com/tgbugs/musl/releases/download/icedtea-bin-3.18.0-alpine-helper-0/"
ARG TMCH=34581ad0f14b5898abfb8d0a7ad89d560270a2e5
RUN \
mkdir -p /usr/local/portage/dev-java/icedtea-bin \
&& pushd /usr/local/portage/dev-java/icedtea-bin \
&& ln -s /var/db/repos/musl/dev-java/icedtea-bin/files \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/icedtea-bin-3.18.0.ebuild" \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/Manifest"

FROM busybox:latest

WORKDIR /
COPY --from=builder /var/db/repos /var/db/repos
COPY --from=gentoo/portage:latest /var/db/repos/gentoo /var/db/repos/gentoo
COPY --from=builder /usr/local/portage /usr/local/portage
CMD /bin/true
VOLUME /var/db/repos
#+end_src
* musl
Pushes to https://hub.docker.com/r/tgbugs/musl. \\
Derived from [[https://hub.docker.com/r/gentoo/stage3/tags?page=1&ordering=last_updated&name=musl-hardened][gentoo/stage3:amd64-musl-hardened]] \\
Further derived from https://ftp-osl.osuosl.org/pub/gentoo/releases/amd64/autobuilds/current-stage3-amd64-musl-hardened/ \\
and from https://gitweb.gentoo.org/proj/releng.git/tree/releases/specs/amd64/musl/stage3-hardened.spec
** profile
TODO use =static-libs=?
*** build
#+name: &musl-build-profile
#+begin_src screen
docker build \
--tag tgbugs/musl:profile \
--file musl/profile/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/profile/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

# we don't put this in var/db/repos because repos is managed via tgbugs/repos:latest
ADD docker-profile/base/docker-profile var/db/docker-profile
ADD docker-profile/base/docker-profile.conf etc/portage/repos.conf/docker-profile.conf
ADD docker-profile/base/package.accept_keywords etc/portage/package.accept_keywords/profile
ADD docker-profile/base/package.mask etc/portage/package.mask/profile
#ADD musl/profile/musl.conf etc/portage/binrepos.conf/musl.conf
ADD docker-profile/base/binrepos-multi.conf etc/portage/binrepos.conf/multi.conf

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** etc
**** binrepos.conf
#+begin_src conf :tangle ./musl/profile/musl.conf
[tgbugs-musl]
priority = 100
sync-uri = http://local.binhost:8089/musl
#+end_src
** profile-x
*** build
#+name: &musl-build-profile-x
#+begin_src screen
docker build \
--tag tgbugs/musl:profile-x \
--file musl/profile-x/Dockerfile .
#+end_src

*** file
We do not need to include any of the files from the base profile here
because they are already in musl:updated which this profile should be
combined on top of.
#+begin_src dockerfile :tangle ./musl/profile-x/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD docker-profile/x/docker-profile var/db/docker-profile
ADD docker-profile/base/binrepos-multi.conf etc/portage/binrepos.conf/multi.conf

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** etc
**** binrepos.conf
#+begin_src conf :tangle ./musl/profile-x/musl-x.conf
[tgbugs-musl-x]
priority = 200
sync-uri = http://local.binhost:8089/musl-x
#+end_src

** profile-static-x
*** build
#+name: &musl-build-profile-static-x
#+begin_src screen
docker build \
--tag tgbugs/musl:profile-static-x \
--file musl/profile-x/static.Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/profile-x/static.Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD docker-profile/x/docker-profile var/db/docker-profile
ADD docker-profile/static/docker-profile var/db/docker-profile
ADD docker-profile/base/binrepos-multi.conf etc/portage/binrepos.conf/multi.conf

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** etc
**** binrepos.conf
#+begin_src conf :tangle ./musl/profile-x/musl-static-x.conf
[tgbugs-musl-static-x]
priority = 400
sync-uri = http://local.binhost:8089/musl-static-x
#+end_src
** user
#+name: &musl-build-user
#+begin_src screen
docker build \
--tag tgbugs/musl:user \
--file musl/user/Dockerfile musl/user
#+end_src

# FIXME this is sufficient to create the default set of files and directories for the user
# however it is not able to deal with the fact that groupadd and useradd still must be run
# on the host system, which leads me to think that the only composability we are going to
# get here is via noweb :/ the primary issue is /etc/groups and other similar things

#+name: &run-user-noskel
#+begin_src bash :eval never
groupadd -g ${UID} ${USER_NAME} \
&& useradd -M -u ${UID} -g ${UID} ${USER_NAME}
#+end_src


Block to be nowebbed for the user creation portion of the images.
Should be +followed+ preceded? by a =COPY --from= that was built by
layering on top of the image we build below.

#+name: &musl-file-user-base
#+begin_src dockerfile
ARG UID=1000
ARG USER_NAME=user

RUN \
<<&run-user-noskel>>

USER $USER_NAME

WORKDIR /home/${USER_NAME}

ENV PATH="/home/${USER_NAME}/.local/bin:${PATH}"
#+end_src

#+name: &musl-user-skel-common
#+begin_src dockerfile
ARG UID=1000
ARG USER_NAME=user

WORKDIR /build

RUN \
groupadd -g ${UID} ${USER_NAME} \
&& useradd -m -k /etc/skel -u ${UID} -g ${UID} -d /build/home/${USER_NAME} ${USER_NAME}

RUN \
mkdir -p home/${USER_NAME}/.local/bin

RUN \
chown -R ${UID}:${UID} home/${USER_NAME}
#+end_src

#+begin_src dockerfile :tangle ./musl/user/Dockerfile
FROM gentoo/stage3:amd64-musl-hardened as builder

<<&musl-user-skel-common>>

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

** portage-maven
Hack to make it possible to install from maven using portage.
*** build
#+name: &musl-build-portage-maven
#+begin_src screen
docker build \
--tag tgbugs/musl:portage-maven \
--file musl/portage-maven/Dockerfile musl/portage-maven
#+end_src

*** file
The UID for portage is static so it is ok to hard code it [fn::
https://api.gentoo.org/uid-gid.txt
https://wiki.gentoo.org/wiki/Project:Quality_Assurance/UID_GID_Assignment].

#+name: &portage-maven-settings
#+begin_src xml :tangle ./musl/portage-maven/settings.xml :mkdirp yes
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd">
  <localRepository>/var/tmp/portage/.m2/repository</localRepository>
</settings>
#+end_src

#+name: &run-portage-maven-1
#+begin_src bash :eval never :noweb yes
# mkdir -p var/lib/portage/home/.m2 \
chown -R 250:250 var/lib/portage \
&& mkdir -p var/tmp/portage/.m2/repository \
&& chown -R 250:250 var/tmp/portage
#+end_src

#+begin_src dockerfile :tangle ./musl/portage-maven/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD settings.xml var/lib/portage/home/.m2/settings.xml

RUN \
<<&run-portage-maven-1>>

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

** eselect-repo
This is where everything starts. The profile has to be set here etc.
*** run
#+begin_src screen
docker run \
--volumes-from local-portage-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-it tgbugs/musl:eselect-repo
#+end_src

# debug
#+begin_src screen :exports none
docker run -it tgbugs/musl:eselect-repo
#+end_src

*** build
#+name: &musl-build-eselect-repo
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:eselect-repo \
--file musl/eselect-repo/Dockerfile musl/eselect-repo
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/eselect-repo/Dockerfile
FROM gentoo/stage3:amd64-musl-hardened

<<&gentoo-file-eselect-repo-common-1>>

COPY --from=tgbugs/musl:profile / /

<<&gentoo-file-eselect-repo-common-2>>

RUN \
eselect profile set docker-profile:tgbugs/musl

<<&gentoo-file-eselect-repo-common-3>>

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
eselect repository enable musl
#+end_src

#+name: &gentoo-file-eselect-repo-common-1
#+begin_src dockerfile
ARG ARCHIVE
ARG PYTHON_TARGETS  # use if there are issues with mismatched python targets
#+end_src

#+name: &gentoo-file-eselect-repo-common-2
#+begin_src dockerfile
RUN \
eselect news read all \
&& eselect news purge

RUN \
mkdir /etc/portage/package.accept_keywords \
;  mkdir /etc/portage/package.env \
;  mkdir /etc/portage/package.mask \
;  mkdir /etc/portage/package.unmask \
;  mkdir /etc/portage/package.use \
;  mkdir /etc/portage/repos.conf \
|| true
#+end_src

#+name: &gentoo-file-eselect-repo-common-3
#+begin_src dockerfile
RUN \
echo "MAKEOPTS=\"-j$(nproc)\"" >> /etc/portage/make.conf \
&& [[ -z ${PYTHON_TARGETS} ]] || \
   echo "*/* PYTHON_TARGETS: -* ${PYTHON_TARGETS}" >> /etc/portage/package.use/00-base
# XXX setting PORTAGE_BINHOSTS has to come later? maybe as an envar?

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge --info 2>&1 | { grep Invalid\ atom && exit 1; exit 0; }

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q \
   --getbinpkg \
   dev-vcs/git \
   app-eselect/eselect-repository \
<<&archive-or-rm>>

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
eselect repository add tgbugs-overlay git https://github.com/tgbugs/tgbugs-overlay.git \
&& eselect repository enable lisp
#+end_src
# TODO should we be adding the mount points here as well or is that not necessary?

** updated
*** file
Produce an up-to-date base image for =amd64-hardened-musl= from the
latest stage3 image including the
[[https://github.com/gentoo/musl][musl overlay]] as noted on the
[[https://wiki.gentoo.org/wiki/Project:Hardened_musl#Working_with_musl][wiki]].

At the moment the docker images are generated far more frequently than
the underlying stage3 tarballs are updated, so there are two docker
files, one for building the first time and another for running routine
emerge updates until a new stage3 is released.

Alternately, one way to avoid rebuilds is to build packages and store
them across rebuilds. This will take more work, but ultimately might
be a bit more reproducible since we would avoid the issues with having
an image building =FROM= a prior version of itself.

#+name: &musl/updated
#+begin_src dockerfile :tangle ./musl/updated/Dockerfile
FROM tgbugs/musl:eselect-repo

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q -uDN @system @world \
   --getbinpkg \
   --keep-going \
   --exclude sys-process/procps \
|| echo $? > /emerge-fail \
<<&archive-or-rm>>

# fail if emerge fails but for buildkit ensure that we do it in such a
# way that we can truncate further steps and create a debug image
RUN \
test ! -e /emerge-fail

RUN \
eselect gcc set $(eselect gcc list | tail -n 1 | awk '{ print $2 }')
#+end_src

*** build
#+name: &musl-build-updated
#+begin_src screen
docker build \
--tag tgbugs/musl:updated \
--network host \
--add-host local.binhost:127.0.0.1 \
--file musl/updated/Dockerfile musl/updated
#+end_src

*** rebuild
#+begin_src bash
docker build \
--tag tgbugs/musl:updated-remerge \
--file musl/updated/remerge.Dockerfile musl/updated

# check that everything works as expected (and that there were changes at all)
docker run -it tgbugs/musl:updated-remerge

# rename the image
docker image tag tgbugs/musl:updated-remerge tgbugs/musl:updated
#+end_src

*** run
#+name: &musl-run-updated
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
-it tgbugs/musl:updated
#+end_src
** updated-user
An example of how to compose user images to minimize size.
*** run
#+begin_src bash
docker run -it tgbugs/musl:updated-user
#+end_src

*** build
#+name: &musl-build-updated-user
#+begin_src bash
docker build \
--tag tgbugs/musl:updated-user \
--build-arg UID=${UID} \
--file musl/updated-user/Dockerfile musl/updated-user
#+end_src

*** file
#+begin_src dockerfile yes :tangle ./musl/updated-user/Dockerfile
FROM tgbugs/musl:updated

# change this line to copy from whatever user image you need
COPY --from=tgbugs/musl:user / /

<<&musl-file-user-base>>
#+end_src

** xorg
# FIXME why is this not being built from binpkg only? is it for layer
# efficiency?
*** run
#+name: &musl-run-xorg
#+begin_src bash
# -v ~/files/binpkgs/musl:/var/cache/binpkgs \
docker run \
--volumes-from local-repos-snap \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
-it tgbugs/musl:xorg
#+end_src
debug
#+begin_src screen
docker run \
--net host \
--add-host local.binhost:127.0.0.1 \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
--rm \
-it \
tgbugs/musl:xorg
#+end_src
*** build
#+name: &musl-build-xorg
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:xorg \
--file musl/xorg/Dockerfile musl/xorg
#+end_src

*** file
The really good news here is that portage ignores packages that were
built with mismatched use flags, so at the end of the day what we will
wind up with is a case where only packages with mismatched flags will
be built and deposited into musl-x. The less good news is that this is
not fully implemented yet as noted in <https://wiki.gentoo.org/wiki/
Binary_package_guide#Pulling_packages_from_a_binary_package_host>.

#+begin_src dockerfile :tangle ./musl/xorg/Dockerfile
ARG PROFILE_IMAGE=tgbugs/musl:profile-x
ARG START_IMAGE=tgbugs/musl:updated

FROM ${PROFILE_IMAGE} as profile_image

FROM ${START_IMAGE}

COPY --from=profile_image / /

ARG PROFILE=docker-profile:tgbugs/musl/x

RUN \
eselect profile set $PROFILE

# FIXME I think we have to update binhosts here

#RUN \
#echo '*/* X' >> /etc/portage/package.use/20-xorg \
#&& echo '*/* VIDEO_CARDS: -*' >> /etc/portage/package.use/20-xorg

# FIXME this rebuild is bad because it results in duplication of
# rebuilt packages between layers, probably need updated-x
# XXX install freetype without harfbuzz first to avoid the circular dependency (sigh)
# XXX NOTE when harfbuzz and freetype are installed from binpkgs sometimes fontconfig
# will scream about missing libs, this is because the good harfbuzz is installed after
# fontconfig, confusing and scary, but apparently not fatal
RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
# FIXME tgbugs-overlay symlinks
ln -s /var/db/repos/gentoo /usr/portage \
&& emerge --getbinpkgonly --binpkg-respect-use=y media-libs/freetype \
|| USE=-harfbuzz emerge -j4 -1q \
   media-libs/freetype \
&& emerge -j1 -q -uDN @world \
   --getbinpkg \
   --binpkg-respect-use=y \
   --exclude sys-process/procps \
   --keep-going \
|| echo $? > /emerge-fail \
<<&archive-or-rm>>

RUN \
test ! -e /emerge-fail

RUN \
eselect fontconfig disable 10-hinting-slight.conf \
&& eselect fontconfig enable \
   10-no-sub-pixel.conf \
   57-dejavu-sans.conf \
   57-dejavu-sans-mono.conf
#+end_src

# FIXME 10-hinting-slight.conf no longer exists now ???

The issues with freetype hinting are partially dealt with in the
profile because so many packages pull in freetype, we have to deal
with the issue globally. We deal with some lingering issues here.

Only enabling dejavu sans and disabling any and all hinting matters.
There isn't a way to disable antialiasing using the gentoo fontconfig
and even if you do the disabled hinting engine has different and ugly
behavior compared to =-cleartype-hinting= so not sure what is going on
for even further insanity if you enable =10-hinting-none.conf= OR
=10-unhinted.conf= *YOU WILL GET HINTING !?!?!??! WAT!?* or at least
maybe AA is enabled which does not maybe ANY sense. Probably there is
some logic which is that in order to disable some feature there is
some default that is enabled so there winds up being a difference
between there being no reference to a feature and a reference to it to
explicitly disable it. Sigh.

** static-xorg
*** run
debug
#+begin_src screen
docker run \
--net host \
--add-host local.binhost:127.0.0.1 \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
--rm \
-it \
tgbugs/musl:static-xorg
#+end_src
*** build
#+name: &musl-build-static-xorg
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:static-xorg \
--build-arg PROFILE='docker-profile:tgbugs/musl/static/x' \
--build-arg PROFILE_IMAGE='tgbugs/musl:profile-static-x' \
--file musl/xorg/Dockerfile musl/xorg
#+end_src
# --build-arg START_IMAGE='tgbugs/musl:xorg' \
** package-builder
*** populate 0
Yes it is kind of annoying to fully split the packages here when many of them don't actually
change, but I don't have an easy way to detect when it is safe to symlink a nox build into
the X build, though I think we can create a processes that would check the packages and to
see whether they have identical metadata and then remove one and symlink the other ....


A brief note on various =bindist= warnings that may appear during this step.

For =openssh= and =openssl=, the issue is related to various patents on ECC and RC5.
As far as I can tell from https://en.wikipedia.org/wiki/ECC_patents and the reference
in https://en.wikipedia.org/wiki/RC5, these patents have all expired, so redistribution
of packages compiled with =-bindist= is not an issue.

For =freetype= it seems that most of the patents https://freetype.org/patents.html
have expired as well. The latest ebuild in the tree has removed bindist entirely.

# it is safe to use --include-config here becauseit is done before any modifications are made
# FIXME TODO need a way to ignore existing exact matches unless we override
#+name: &musl-run-xorg-quickpkg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
--rm \
tgbugs/musl:xorg \
quickpkg "*/*"
#+end_src

*** run
#+begin_src bash
function build_package () {
echo docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
--rm \
tgbugs/musl:package-builder \
$@
}
#+end_src


#+begin_src bash
build_package sh -c "USE=-harfbuzz emerge -1q freetype"
# and here we see why I keep harfbuzz out of the nox profile
build_package sh -c "emerge -1q freetype"
#+end_src

# TODO it is almost certainly worth keeping these containers around
# and stashing them because they can be used to build more packages
# without having to do a full reinstall, which still takes awhile

# TODO figure out how to properly archive distfiles and binpkgs

# FIXME there is a nasty issue here with composability for use flag
# changes in the profile, in all likelihood we would be better off
# maintaining a stack layers on the builder to update the use flags
# independent of the profile until we we know that we have to do a
# full rebuild, simply because rebuilding build images from scratch
# every time is still slow and adding new packages will almost
# inevitably reveal issues that require such use changes many should
# go in the profile because we know that we are always going to need
# those in the future, it should be fairly straight forward to create
# a /var/db/docker-profile -> /etc/portage translator for the builder

#+name: &builder-resnap
#+begin_src bash
export _tm_pbs=tgbugs/musl:package-builder-snap
export _tm_s_pbs=tgbugs/musl:static-package-builder-snap
function builder-resnap () {
docker run tgbugs/musl:package-builder
docker commit $(docker ps -lqf ancestor=tgbugs/musl:package-builder) ${_tm_pbs}
}
# FIXME SIGH SIGH SIGH why is this easier than doing the right thing
function static-builder-resnap () {
docker run tgbugs/musl:static-package-builder
docker commit $(docker ps -lqf ancestor=tgbugs/musl:static-package-builder) ${_tm_s_pbs}
}
#+end_src

#+name: &container-check
#+begin_src bash
function container-check () {
docker container inspect local-repos-snap > /dev/null || \
docker create -v /var/db/repos --name local-repos-snap tgbugs/repos:latest /bin/true

# FIXME need to check that the cross image exists sigh make
docker container inspect cross-sbcl > /dev/null || \
docker create -v /sbcl --name cross-sbcl tgbugs/musl:cross-sbcl /bin/true
}
#+end_src

#+name: &builder-world
#+begin_src bash
function builder-world () {
container-check
cat ./musl/package-builder/world | xargs \
docker run \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going -uDN

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_pbs}) ${_tm_pbs}
}
# FIXME SIGH code dupe
function static-builder-world () {
container-check
cat ./musl/static-package-builder/world | xargs \
docker run \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_s_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going -uDN

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_s_pbs}) ${_tm_s_pbs}
}
#+end_src

#+name: &builder-arb
#+begin_src bash
function builder-arb () {
container-check
# rebuild packages modified without revbump e.g. due to changing /etc/portage/patches
docker run \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going --usepkg=n \
${@}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_pbs}) ${_tm_pbs}
}
# XXX FIXME code dupe
function static-builder-arb () {
container-check
# rebuild packages modified without revbump e.g. due to changing /etc/portage/patches
docker run \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_s_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going --usepkg=n \
${@}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_s_pbs}) ${_tm_s_pbs}
}
#+end_src

There are some packages such as =dev-lang/go= and some cross compiles
that require elevated privs in order to build otherwise they try to
call =process_vm_readv= then die.

See https://github.com/gentoo/gentoo-docker-images/issues/98 and
https://github.com/moby/moby/issues/1916.

#+name: &builder-arb-priv
#+begin_src bash
function builder-arb-priv () {
container-check
# rebuild packages modified without revbump e.g. due to changing /etc/portage/patches
docker run \
--privileged \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going --usepkg=n \
${@}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_pbs}) ${_tm_pbs}
}
# FIXME code dupe
function static-builder-arb-priv () {
container-check
# rebuild packages modified without revbump e.g. due to changing /etc/portage/patches
docker run \
--privileged \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
${_tm_s_pbs} \
emerge --color=y --with-bdeps=y -j4 -q --keep-going --usepkg=n \
${@}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_s_pbs}) ${_tm_s_pbs}
}
#+end_src
# dev-lang/go
# dev-lisp/sbcl cross compile

#+name: &builder-debug
#+begin_src bash
function builder-debug () {
container-check
docker run \
--privileged \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
-it ${_tm_pbs}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_pbs}) ${_tm_pbs}
}
# XXX FIXME code dupe
function static-builder-debug () {
container-check
docker run \
--privileged \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /var/lib/portage/home/.ssh:/var/lib/portage/home/.ssh \
-it ${_tm_s_pbs}

docker commit --change='CMD ["/bin/bash"]' $(docker ps -lqf ancestor=${_tm_s_pbs}) ${_tm_s_pbs}
}
#+end_src

#+begin_src bash
# --nodeps # potentially useful

@live-rebuild

app-misc/screen
dev-lisp/sbcl


# to debug issues
docker run \
--volumes-from local-repos-snap \
--rm \
-it \
tgbugs/musl:package-builder-snap

# too many issues, just merge and get on with it
# the lack of separation between build time dependencies and runtime is quite annoying
# that or the dependency trees are even worse than I thought
# emerge --color=y -j4 -q --keep-going --onlydeps
# emerge --color=y -j4 -q --keep-going --buildpkgonly
#+end_src

*** build
# FIXME cp -r is a hack for the time being, patches should be source more sanely
# cp -r patches/ musl/package-builder/
#+name: &musl-build-package-builder
#+begin_src screen
docker build \
--tag tgbugs/musl:package-builder \
--file musl/package-builder/Dockerfile musl/package-builder
#+end_src

*** file
# TODO distcc
# COPY patches /etc/portage/patches
#+name: &musl-package-builder-common
#+begin_src dockerfile
COPY --from=tgbugs/musl:portage-maven / /

ADD repo_name /var/db/crossdev/profiles/repo_name
ADD layout.conf /var/db/crossdev/metadata/layout.conf
ADD crossdev.conf /etc/portage/repos.conf/crossdev.conf
ADD sbcl.env /etc/portage/env/dev-lisp/sbcl

RUN \
echo 'FEATURES="${FEATURES} buildpkg"' >> /etc/portage/make.conf \
&& echo 'EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkg --binpkg-respect-use=y"' >> /etc/portage/make.conf
#+end_src

#+begin_src dockerfile :tangle ./musl/package-builder/Dockerfile
FROM tgbugs/musl:xorg

<<&musl-package-builder-common>>
#+end_src

*** sbcl bootstrap
The gentoo ebuilds for sbcl retrieve an existing binary for bootstrapping.
Due to the fact that the current EAPI (?) is not libc aware for precompiled
binaries we would have to create and maintain a binary for the musl overlay.
Modifying =src_unpack= is a more expedient solution.
#+begin_src ebuild :tangle ./musl/package-builder/sbcl.env
src_unpack() {
	unpack ${A}
	[ -d /sbcl ] && {
		einfo "Using /sbcl for bootstrap"
		cp -r /sbcl sbcl-binary || die;
		cp -a ${S}/run-sbcl.sh sbcl-binary/ || die;
	} || {
	command -v sbcl && {
		einfo "Using local sbcl found at $(command -v sbcl) for bootstrap"
		local bin_core_home;
		IFS=',' read -r -a bin_core_home <<< $(sbcl --noinform --no-sysinit --no-userinit --eval \
		'(progn (format t "~a,~a,~a" sb-ext:*runtime-pathname* sb-ext:*core-pathname* (sb-int:sbcl-homedir-pathname)))' --quit) || die;
		mkdir -p sbcl-binary/src/runtime || die;
		mkdir -p sbcl-binary/output || die;
		mkdir -p sbcl-binary/obj/sbcl-home || die;
		cp -a ${bin_core_home[0]} sbcl-binary/src/runtime/ || die;
		cp -a ${bin_core_home[1]} sbcl-binary/output/ || die;
		cp -a ${bin_core_home[2]}/contrib sbcl-binary/obj/sbcl-home/contrib || die;
		cp -a ${S}/run-sbcl.sh sbcl-binary/ || die;
	} } ||
	mv sbcl-*-* sbcl-binary || die
	cd "${S}"
}
#+end_src
*** crossdev
In order to fix
#+begin_example
 * Missing digest for '/var/db/docker-profile/cross-x86_64-pc-linux-gnu/binutils/binutils-2.34-r2.ebuild'
 * Missing digest for '/var/db/docker-profile/cross-x86_64-pc-linux-gnu/binutils/binutils-2.33.1-r1.ebuild'
#+end_example

This works around the fact that musl uses thin manifests.  See
https://wiki.gentoo.org/wiki/Custom_ebuild_repository#Crossdev.
#+begin_src conf :tangle ./musl/package-builder/repo_name
crossdev
#+end_src

#+begin_src conf :tangle ./musl/package-builder/layout.conf
masters = gentoo
thin-manifests = true
#+end_src

#+begin_src conf :tangle ./musl/package-builder/crossdev.conf
[crossdev]
location = /var/db/crossdev
priority = 10
masters = gentoo
auto-sync = no
#+end_src

But even with that fix there is an issue with linking the core runtime libs.
#+begin_example
/usr/libexec/gcc/x86_64-pc-linux-gnu/ld: cannot find crti.o: No such file or directory
#+end_example

For reasons I do not fully understand we have to use the gentoo repo
as the source for the gcc ebuild, the two are virtually identical, so
maybe the toolchain eclass is silently different? Unknown.
#+begin_src bash
crossdev --stage4 --stable --target x86_64-pc-linux-gnu --ov-gcc /var/db/repos/gentoo
#+end_src

At this point we can attempt to emerge sbcl, but =src_config= will fail.
#+begin_src bash
x86_64-pc-linux-gnu-emerge -q -j4 sbcl
#+end_src

As a result, I reworked the profile so that it can support whatever
libc we want and do the cross build from gnu to musl since there are
distributed sbcl-binaries for gnu but not for musl. The way that
multiple libcs are implemented in gentoo right now seems to add
significant maintenance overhead due to ebuild duplication.

*** world
#+name: world-package-builder
#+begin_src conf :tangle ./musl/package-builder/world
<<ident((dedupe-lines "world-package-builder-dupes"))>>
#+end_src

#+name: world-package-builder-dupes
#+begin_src conf
<<world-package-builder-nox>>
<<world-kg-release>>
<<world-kg-dev>>
<<world-docker>>
<<world-interlex>>
app-portage/smart-live-rebuild
sys-devel/crossdev
x11-base/xorg-server
x11-libs/gtk+
app-editors/gvim
#+end_src

#+begin_src conf
media-libs/freetype
media-libs/fontconfig
media-fonts/dejavu
#+end_src

** static-package-builder
*** populate 0
#+name: &musl-run-static-xorg-quickpkg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
--rm \
tgbugs/musl:static-xorg \
quickpkg "*/*" --include-config y
#+end_src
*** run
#+begin_src bash
docker run tgbugs/musl:static-package-builder
docker commit $(docker ps -lq) tgbugs/musl:static-package-builder-snap

cat ./musl/package-builder/world | xargs \
docker run \
--volumes-from local-repos-snap \
--volumes-from cross-sbcl \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
tgbugs/musl:static-package-builder-snap \
emerge --color=y -j4 -q --keep-going -uDN

docker commit $(docker ps -lq) tgbugs/musl:static-package-builder-snap
#+end_src
# FIXME racket failing with mkostemp failures during raco make or
# something !? what the fuck?  how was this not caught before ?!
*** build
#+name: &musl-build-static-package-builder
#+begin_src screen
docker build \
--tag tgbugs/musl:static-package-builder \
--file musl/package-builder/static.Dockerfile musl/package-builder
#+end_src
*** file
#+begin_src dockerfile :tangle ./musl/package-builder/static.Dockerfile
FROM tgbugs/musl:static-xorg

<<&musl-package-builder-common>>
#+end_src
*** world
#+name: world-static-package-builder
#+begin_src conf :tangle ./musl/static-package-builder/world
<<world-sbcl>>
<<world-static-sbcl-c-libs>>
#+end_src

#+name: world-static-sbcl-c-libs
#+begin_src conf
dev-libs/openssl
dev-libs/gmp
dev-libs/capstone
dev-libs/mpfr
dev-libs/redland
#+end_src
** package-builder-nox
*** populate 0
#+name: &musl-run-updated-quickpkg
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
--rm \
tgbugs/musl:updated \
quickpkg "*/*"
#+end_src
*** run
#+begin_src bash
cat ./musl/package-builder/nox.world | xargs \
docker run \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
--rm \
tgbugs/musl:package-builder-nox \
emerge --color=y -j4 -q --keep-going
#+end_src
*** world
If there is a new package that one of your images needs add it here.
Yes, there are going to be issues with keywording that are likely going
to require updates to the profile followed by a rebuild here. I can't quite
remember whether binpkgs check use flags.
#+name: world-package-builder-nox
#+begin_src conf :tangle ./musl/package-builder/nox.world
<<world-debug>>
<<world-emacs>>
<<world-dynapad-base>>
<<world-python>>
<<world-schemes>>
dev-lisp/sbcl
#+end_src

# requires a crossdev environment for this to work
#+name: world-lisp
#+begin_src conf
dev-lisp/sbcl
dev-lisp/clozurecl
dev-lisp/clisp
#+end_src

#+name: world-schemes
#+begin_src conf
dev-scheme/chicken
dev-scheme/guile
dev-scheme/gambit
#+end_src
# TODO build Chez from the Racket repo for unencumbered boot files
#+name: world-xemacs
#+begin_src conf
app-editors/xemacs
app-xemacs/xemacs-packages-all
#+end_src

*** build
#+name: &musl-build-package-builder-nox
#+begin_src screen
docker build \
--tag tgbugs/musl:package-builder-nox \
--file musl/package-builder/nox.Dockerfile musl/package-builder
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/package-builder/nox.Dockerfile
FROM tgbugs/musl:updated

<<&musl-package-builder-common>>
#+end_src

** package-binhost
** binpkg-only
*** build
#+name: &musl-build-binpkg-only
#+begin_src bash
docker build \
--tag tgbugs/musl:binpkg-only \
--file musl/binpkg-only/Dockerfile musl/binpkg-only
#+end_src

*** file
# wow parallel-install -ebuild-locks speeds things up quite a bit
# unfortunately they break acct-group and acct-user packages
# due to /etc/gshadow.lock contention which I think happends due
# to the -ebuild-locks feature because setting that allows
# unsandboxed steps to install concurrently
#+name: &musl-binpkg-only-common
#+begin_src dockerfile

RUN \
echo 'EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkgonly --getbinpkgonly"' >> /etc/portage/make.conf \
&& echo 'FEATURES="${FEATURES} parallel-install -ebuild-locks"' >> /etc/portage/make.conf
#+end_src

#+begin_src dockerfile :tangle ./musl/binpkg-only/Dockerfile
FROM tgbugs/musl:xorg
<<&musl-binpkg-only-common>>
#+end_src

** static-binpkg-only
*** build
#+name: &musl-build-static-binpkg-only
#+begin_src bash
docker build \
--tag tgbugs/musl:static-binpkg-only \
--file musl/binpkg-only/static.Dockerfile musl/binpkg-only
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/binpkg-only/static.Dockerfile
FROM tgbugs/musl:static-xorg
<<&musl-binpkg-only-common>>
#+end_src

** binpkg-only-nox
*** build
#+name: &musl-build-binpkg-only-nox
#+begin_src screen
docker build \
--tag tgbugs/musl:binpkg-only-nox \
--file musl/binpkg-only/nox.Dockerfile musl/binpkg-only
#+end_src

*** file
# FIXME not quite right, this is the vanilla, which leaves X enabled for some things
#+begin_src dockerfile :tangle ./musl/binpkg-only/nox.Dockerfile
FROM tgbugs/musl:updated
<<&musl-binpkg-only-common>>
#+end_src

** debug
*** world
#+name: world-debug
#+begin_src conf
app-editors/vim
app-portage/eix
sys-devel/gdb::musl
#+end_src
** testing-python
Python testing.
*** world
#+name: world-python
#+begin_src conf :tangle ./musl/testing-python/world
dev-lang/python:3.6
dev-lang/python:3.7
dev-lang/python:3.8
dev-lang/python:3.9
dev-python/pip
#+end_src
# XXX pipenv continues to be a toxic waste dump of insanity and brokeness
# https://bugs.gentoo.org/717666 really really bad call on my part for
# picking it back in 2018 because Pipfile seemed useful
# LOL PYTHON pipenv bundles tomli but apparently has a hard upper version limit in the ebuild? wat
# dev-python/pipenv
** pypy3 notes
If you load up =builder-debug= you can emerge pypy3 by adding patches
manually, the right thing to do is to update the musl overlay build,
but for now, if you can manage to manually build in the builder you
will wind up with a binpkg that can be reused.

https://bugs.python.org/issue21622
https://github.com/python/cpython/pull/18380
https://bugs.python.org/issue43112
# AAAAAAAAAAAAAAAAAAAAAAAAAAaa
# So yes ... my suspicion that invariance to libc is completely neglected is completely vindicated
This patch fixes the problem
https://git.alpinelinux.org/aports/plain/main/python3/musl-find_library.patch
stick it in /etc/portage/patches/dev-lang/python:2.7/musl-find_library.patch

https://raw.githubusercontent.com/gentoo/musl/master/dev-python/pypy3-exe/files/pypy3-exe-7.3.0-musl-compat-fix-stdio-defs.patch
# https://raw.githubusercontent.com/gentoo/musl/master/dev-python/pypy3-exe/files/pypy3-exe-7.3.0-musl-compat-include-sys-time.patch
https://github.com/gentoo/musl/issues/451#issuecomment-1017102775
# rebuild binpkgs emerge -g n -k n package-name
#+begin_src diff :tangle musl/profile/patches/dev-python/pypy3-3.7.3/lol.patch :mkdirp yes
diff -r 9ef55f6fc369 pypy/module/cpyext/include/pytime.h
--- a/pypy/module/cpyext/include/pytime.h
+++ b/pypy/module/cpyext/include/pytime.h
@@ -2,6 +2,10 @@
 #ifndef Py_PYTIME_H
 #define Py_PYTIME_H
 
+#ifndef MS_WINDOWS
+#include <sys/time.h>
+#endif
+
 #include <pyconfig.h> /* include for defines */
 #include "object.h"
 
#+end_src

pip install --user -e . is broken for <=dev-python/setuptools-60 sigh

# TODO I think this goes in the profile? or maybe along with the repos or something?
# /etc/portage/patches is a super power for stuff like this
#+begin_src dockerfile
ADD musl/?/lol.patch /etc/portage/patches/dev-python/pypy3-3.7.3/lol.patch
#+end_src

** testing-emacs
Emacs testing.
*** world
#+begin_src conf :tangle ./musl/testing-emacs/world
app-editors/emacs:18
app-editors/emacs:23
app-editors/emacs:24
app-editors/emacs:25
app-editors/emacs:26
app-editors/emacs:27
app-editors/emacs:28-vcs
app-editors/emacs:29-vcs
#+end_src
** emacs
Emacs using the athena 3d toolkit to avoid pulling in gtk.
*** run
#+begin_src screen
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:emacs
#+end_src

debug run
#+begin_src screen
docker run \
--net host \
--add-host local.binhost:127.0.0.1 \
--volumes-from local-repos-snap \
-v ~/files/binpkgs/multi:/var/cache/binpkgs \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=${DISPLAY} \
--rm \
-it \
tgbugs/musl:emacs
#+end_src

If you see the following error you somehow forgot/are missing the musl overlay.
#+begin_example
Error loading shared library libbsd.so.0: No such file or directory (needed by /usr/lib/libICE.so.6)
Error loading shared library libbsd.so.0: No such file or directory (needed by /usr/lib/libXdmcp.so.6)
Error relocating /usr/lib/libICE.so.6: arc4random_buf: symbol not found
Error relocating /usr/lib/libXdmcp.so.6: arc4random_buf: symbol not found
#+end_example

*** build
#+name: &musl-build-emacs
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:emacs \
--file musl/emacs/Dockerfile musl/emacs
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/emacs/Dockerfile
<<&build-world>>
#+end_src

#+begin_src dockerfile :tangle ./musl/emacs/nox.Dockerfile
<<&build-world-nox>>
#+end_src

*** world
# FIXME I think something in the emacs ebuild is broken because sometimes it fails to pull in libbsd???
#+name: world-emacs
#+begin_src conf :tangle ./musl/emacs/world
app-emacs/vterm
app-editors/emacs
#+end_src

** icedtea
*** build
#+name: &musl-build-icedtea
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:icedtea \
--file musl/icedtea/Dockerfile musl/icedtea
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/icedtea/Dockerfile
<<&build-world>>
#+end_src
*** world
# FIXME BROKEN
#+name: world-icedtea-broken
#+begin_src conf :tangle ./musl/icedtea/world :tangle no
dev-java/icedtea-bin::musl
#+end_src

Backup.
#+name: world-icedtea
#+begin_src conf :tangle ./musl/icedtea/world
dev-libs/nss
x11-libs/libXcomposite
x11-libs/libXtst
dev-java/icedtea-bin::musl
#+end_src
# back to musl since somehow my local setup is broken for the package builder
# and the musl repo is fixed again and I managed to pull everything down this time
# dev-java/icedtea-bin::local

# note the lack of tangle
#+name: world-icedtea-nox
#+begin_src conf
dev-libs/nss
dev-java/icedtea-bin::local
#+end_src

*** legacy
The musl overlay installs icedtea-bin correctly now so this is
+thankfully no longer needed+ only needed periodically.
#+name: &musl/icedtea/legacy
#+begin_src dockerfile :tangle ./musl/icedtea/legacy.Dockerfile
FROM tgbugs/musl:xorg

ARG ARCHIVE

ARG BASE="https://github.com/tgbugs/musl/releases/download/icedtea-bin-3.18.0-alpine-helper-0/"

ARG TMCH=34581ad0f14b5898abfb8d0a7ad89d560270a2e5

RUN \
eselect repository create local /usr/local/portage

# FIXME this is an evil hack that WILL expire
RUN \
mkdir -p /usr/local/portage/dev-java/icedtea-bin \
&& pushd /usr/local/portage/dev-java/icedtea-bin \
&& ln -s /var/db/repos/musl/dev-java/icedtea-bin/files \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/icedtea-bin-3.18.0.ebuild" \
&& curl -L -O "https://raw.githubusercontent.com/tgbugs/musl/${TMCH}/dev-java/icedtea-bin/Manifest"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q nss \
<<&archive-or-rm>>

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
emerge -j4 -q dev-java/icedtea-bin::local --onlydeps \
<<&archive-or-rm>>

ARG SIGH="icedtea-bin-3.18.0-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-dbg-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-doc-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-base-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-lib-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-jre-x86_64-musl.tar.gz \
icedtea-bin-3.18.0-libjpeg-x86_64-musl.tar.gz"

RUN --mount=from=gentoo/portage:latest,source=/var/db/repos/gentoo,target=/var/db/repos/gentoo,rw \
pushd /var/cache/distfiles \
&& for SI in ${SIGH}; do curl -L -o "${SI}" "${BASE}${SI/-musl/}"; done \
&& popd \
&& emerge -j4 -q dev-java/icedtea-bin::local \
<<&archive-or-rm>>
#+end_src

# export failure=$(docker ps -lq)
# docker start $failure
# docker attach $failure

** protege
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege
#+end_src

*** build
#+name: &musl-build-protege
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:protege \
--build-arg UID=${UID} \
--file musl/protege/Dockerfile musl/protege
#+end_src

Due to the fact that protege needs X11 running in order to create
config files.  Run the following command, change the default reasoner
to ELK, make any other changes that are needed, and then quit protege.
The second command will run automatically and commit the changes.

NOTE you must run the =protege= command manually to prevent the commit
from changing the default behavior of the container from changing its
entry point to run =protege=.

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:protege && \
docker commit $(docker ps -lq) tgbugs/musl:protege
#+end_src

*** world
#+name: world-protege
#+begin_src conf :tangle ./musl/protege/world
<<world-icedtea>>
dev-python/pip
#+end_src
*** file
We install pip during this step because any builds that =FROM
tgbugs/musl:protege= default to =protegeuser=.
# TODO FIXME we should be able to install protege as root
#+name: &musl/protege
#+begin_src dockerfile :tangle ./musl/protege/Dockerfile
FROM tgbugs/musl:icedtea as builder

ARG ARCHIVE
ARG PROTEGE_VERSION="5.5.0"

<<&musl-user-skel-common>>

USER ${USER_NAME}

ARG HOME=/build/home/${USER_NAME}

WORKDIR $HOME

# phase two protege and reasoners
ARG URL_PROTEGE="https://github.com/protegeproject/protege-distribution/releases/download/v5.5.0/Protege-5.5.0-linux.tar.gz"
ARG URL_ELK="https://github.com/liveontologies/elk-reasoner/releases/download/v0.4.3/elk-distribution-0.4.3-protege-plugin.zip"
ARG URL_FACT="https://bitbucket.org/dtsarkov/factplusplus/downloads/uk.ac.manchester.cs.owl.factplusplus-P5.x-v1.6.5.jar"

RUN \
cd ~/ \
&& curl -L -O ${URL_PROTEGE} \
&& tar xvzf Protege-${PROTEGE_VERSION}-linux.tar.gz \
&& pushd Protege-${PROTEGE_VERSION} \
&& rm jre/ -r \
&& sed -i 's/^jre\/bin\/java/\/usr\/bin\/java/' run.sh \
&& sed -i 's/500M/12G/' run.sh \
&& sed -i 's/200M/5G/' run.sh \
&& sed -i 's/16M/160M/' run.sh \
&& pushd plugins \
&& curl -L -O ${URL_FACT} \
&& curl -L -O ${URL_ELK} \
&& unzip -p elk-distribution-0.4.3-protege-plugin.zip \
   elk-distribution-0.4.3-protege-plugin/org.semanticweb.elk.jar \
   > org.semanticweb.elk-0.4.3.jar \
&& rm elk-distribution-0.4.3-protege-plugin.zip \
&& popd; popd \
&& mkdir -p ~/.local/share ~/.local/bin \
&& mv Protege-${PROTEGE_VERSION} ~/.local/share/ \
&& pushd ~/.local/bin \
&& ln -s ../share/Protege-${PROTEGE_VERSION}/run.sh protege \
&& popd \
&& rm Protege-${PROTEGE_VERSION}-linux.tar.gz

# paths to preferences files
ARG PATH_CFU_1=_\!\&\!\!\`g\"\>\!\&@\!\[@\"\(\!%\`\!\|w\"@\!\&\)\!\[@\"\'\!%\`\!\`g\"\&\!%4\!@w\"\&\!\&:=
ARG PATH_CFU_2=_\!\'%\!c\!\"w\!\'w\!a@\"j\!\'%\!d\!\"p\!\'8\!bg\"f\!\(\!\!cg\"l\!\'\}\!~@\"y\!\'\`\!bg\"j\!\'\`\!cw==
ARG PATH_CFU_3=_\!\'8\!cg\"n\!#4\!c\!\"y\!\'8\!d\!\"l\!\'c\!~@\!u\!\'\`\!~\!\"p\!\(@\!bw\"y\!#4\!\}w\"v\!\(\)\!~@\!u\!\(\`\!c\!\"k\!\'%\!d\!\"l\!#4\!\`\!\"s\!\(\`\!~w\"p\!\'4\!\^@\"h\!\'4\!\}@\"n\!\'\`\!cg==
ARG PATH_CFU="${PATH_CFU_1}/${PATH_CFU_2}/${PATH_CFU_3}"

# set preferences so that protege starts in the right state the first time
# protege doesn't create this prefs file by default so we would have to do this regardless
# this helps because it prevents the search for plugins on first run so that goes faster
RUN \
pushd ~/ \
&& mkdir -p ".java/.userPrefs/${PATH_DRI_1}" \
&& chmod 0700 ".java/.userPrefs" \
&& mkdir -p ".java/.userPrefs/${PATH_CFU}" \
&& echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<!DOCTYPE map SYSTEM "http://java.sun.com/dtd/preferences.dtd">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '<map MAP_XML_VERSION="1.0">' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '  <entry key="CheckForUpdates" value="false"/>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& echo '</map>' >> ".java/.userPrefs/${PATH_CFU}/prefs.xml" \
&& popd

FROM tgbugs/musl:icedtea

<<&build-world-common>>

COPY --from=builder /build /

<<&musl-file-user-base>>
#+end_src

Sadly this approach does not work because protege dies before the
reasoner prefs file is written.  Therefore we have to run the image
manually and commit before release. Sigh.
#+begin_src dockerfile
# start protege to generate settings files, have to sleep becuase the
# protege sh wrapper breaks $!
RUN \
protege \
& sleep 6 \
&& kill $(ps | grep java | awk '{ printf $1 }')

# on first run protege doesn't check to see if there is already
# something in this prefs.xml file and appends to it automatically
RUN \
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; \
-exec sed -i 's/org.protege.editor.owl.NoOpReasoner/org.semanticweb.elk.elk.reasoner.factory/' {} \;

# must use absolute path otherwise command form won't work
WORKDIR /home/${USER_NAME}
#+end_src

In order to get paths that point to the prefs.xml files that we can
embed in the docker file you need the following commands.
#+begin_src bash
printf '%q' $(find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q CheckForUpdates {} \; -print0)
#+end_src

A useful find command for debugging whether the correct reasoner has been set.
#+begin_src bash
find ~/.java/.userPrefs -name 'prefs.xml' -exec grep -q DEFAULT_REASONER_ID {} \; -exec cat {} \;
#+end_src

** NIF-Ontology
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:NIF-Ontology
#+end_src

*** build
# TODO progress prints to stderr
#+name: &musl-build-NIF-ontology
#+begin_src bash
docker build \
--tag tgbugs/musl:NIF-Ontology \
--file musl/NIF-Ontology/Dockerfile musl/NIF-Ontology
#+end_src

*** file
# FIXME composition with protege user issues I think the right way to
# do this is to move to having a single container user image that we
# build and then use COPY --from on that?
#+name: &musl/NIF-Ontology
#+begin_src dockerfile :tangle ./musl/NIF-Ontology/Dockerfile
FROM tgbugs/musl:protege

# phase three ontology
RUN \
pushd ~/ \
;   mkdir git \
;   pushd git \
;       git clone https://github.com/SciCrunch/NIF-Ontology.git \
;       pushd NIF-Ontology \
;           pushd ttl \
;           cp catalog-v001.xml.example catalog-v001.xml \
;       popd \
;   popd
#+end_src

** neurondm
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:neurondm

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:neurondm \
protege
#+end_src

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:neurondm \
--build-arg ONTOLOGY_GITREF=neurons \
--file musl/neurondm/Dockerfile musl/neurondm
#+end_src

*** file
#+name: &musl/neurondm
#+begin_src dockerfile :tangle ./musl/neurondm/Dockerfile
FROM tgbugs/musl:NIF-Ontology

ARG ONTOLOGY_GITREF=neurons

# phase three ontology
RUN \
pushd ~/git/NIF-Ontology \
;   git checkout ${ONTOLOGY_GITREF} \
;   popd

# phase four python tools
RUN \
pushd ~/ \
;   pushd git \
;       git clone https://github.com/tgbugs/pyontutils.git \
;       pushd pyontutils \
;           pip install --user -e . \
;           pushd neurondm \
;               pip install --user -e . \
;           popd \
;       popd \
;   popd
#+end_src

** npo-1.0
*** run
#+begin_src bash
xhost local:docker

docker pull tgbugs/musl:npo-1.0

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
**** macos notes
#+begin_src bash
brew install virtualbox  # there are some system level persmissions that you will need to set
brew install --cask docker
open -a Docker\ Desktop
# You will need to go to Docker Desktop > Preferences > Resources
# and increase the memory limit to 8 gigs
# otherwise oom killer will end Protege while trying to load npo.ttl

brew install xquartz
open -a XQuartz
# You will need to go to XQuartz > Preferences > Security
# and enable Allow connections from network clients
xhost +localhost
export DISPLAY=:0
# test to make sure everything still works e.g. by running xeyes

docker pull tgbugs/musl:npo-1.0
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=host.docker.internal$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0 \
sh -c 'protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src

Run the block above and once protege starts type =Control R= to run
the reasoner. The docker image is running the Linux version of Protege
so the key bindings use Control instead of Command. You can then run
OWL DL queries in the tab. Note that if you are using the ELK reasoner
(enabled by default in the image) then you will have to click through
a number of warning dialogues, this is normal.

*** build
#+begin_src bash
docker build \
--tag tgbugs/musl:npo-1.0 \
--build-arg ONTOLOGY_GITREF=npo-1.0 \
--file musl/neurondm/Dockerfile musl/neurondm
#+end_src

** npo-1.0-neurondm-build
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--workdir /home/protegeuser/git/NIF-Ontology/ttl \
tgbugs/musl:npo-1.0-neurondm-build \
sh -c 'git stash && protege ~/git/NIF-Ontology/ttl/npo.ttl'
#+end_src
*** build
Build using the SciCrunch SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/npo-1.0-neurondm-build/Dockerfile musl/npo-1.0-neurondm-build
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:npo-1.0-neurondm-build \
--build-arg NEURONS_BRANCH=npo-1.0 \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/npo-1.0-neurondm-build/Dockerfile musl/npo-1.0-neurondm-build
#+end_src
# --build-arg SCIGRAPH_API=http://192.168.1.207:9000/scigraph \

*** file
# FIXME should probably be using a multi source file here instead of
# noweb but I'm not sure we can really do that because the output
# depends on the state of the ontology repo
#+name: &musl/neurondm-build
#+begin_src dockerfile :tangle ./musl/npo-1.0-neurondm-build/Dockerfile
FROM tgbugs/musl:npo-1.0
<<&-base-musl/neurondm-build>>
#+end_src

*** save
This is the image that will be archived to Zenodo for the paper. Note
that the dl queries will not run as expected on this unless you first
stash the changes in =~/git/NIF-Ontology=.

#+begin_src bash
docker save tgbugs/musl:npo-1.0-neurondm-build | gzip > /tmp/npo-1.0-neurondm-build.tar.gz
#+end_src

To restore from the archive run
#+begin_src bash
docker load --input npo-1.0-neurondm-build.tar.gz
#+end_src

The sha256 checksum for npo-1.0-neurondm-build.tar.gz on Zenodo at
doi:10.5281/zenodo.5033493 is
=8e0bb1c684ca8a28f1abeb01ef7aa2597388b8011244f097a92bdd2a523db102=.

** neurondm-build
This image runs the neurondm build process.
*** run
*** build
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--secret id=scigraph-api-key,src=<(echo export SCIGRAPH_API_KEY=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api-key"))')) \
--file musl/neurondm-build/Dockerfile musl/neurondm-build
#+end_src

Build using an alternate SciGraph API endpoint.
#+begin_src bash
# XXX note that NUID does nothing right now
docker build \
--tag tgbugs/musl:neurondm-build \
--build-arg NUID=${UID} \
--build-arg SCIGRAPH_API=$(python -c 'from pyontutils.config import auth; print(auth.get("scigraph-api"))') \
--secret id=scigraph-api-key,src=<(echo) \
--file musl/neurondm-build/Dockerfile musl/neurondm-build
#+end_src

*** file
#+name: &musl/neurondm-build
#+begin_src dockerfile :tangle ./musl/neurondm-build/Dockerfile
FROM tgbugs/musl:neurondm
<<&-base-musl/neurondm-build>>
#+end_src

#+name: &-base-musl/neurondm-build
#+begin_src dockerfile
# phase five build
# XXX FIXME we can't run this for the demonstrator because the lack of
# npokb identifiers causes the queries to fail we probably want two
# separate images for this
ARG SCIGRAPH_API
ARG NEURONS_BRANCH
ARG NUID=11741
# FIXME waiting on https://github.com/moby/buildkit/issues/815
#RUN --mount=type=secret,id=scigraph-api-key,uid=${NUID} \
RUN --mount=type=secret,id=scigraph-api-key,uid=1000 source /run/secrets/scigraph-api-key \
; python -m neurondm.models.allen_cell_types \
; python -m neurondm.models.huang2017 \
; python -m neurondm.models.ma2015 \
; git -C ~/git/NIF-Ontology status
#+end_src

** interlex
*** run
WARNING! If you mount your postgres data directory like this make sure
the host system is NOT also running postgres on top of that directory
otherwise you will have a BAD TIME.
#+begin_src screen
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/files/docker-postgres/interlex-dev:/var/lib/postgresql \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:interlex
#+end_src

*** build
#+name: &musl-build-interlex
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:interlex \
--file musl/interlex/Dockerfile musl/interlex
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/interlex/Dockerfile
FROM tgbugs/musl:binpkg-only

ARG FEATURES=ebuild-locks
<<&build-world-common>>
#+end_src
*** world
# app-misc/elasticsearch  # XXX license issues, likely must handle separately
# so that we don't taint the profile, probably want a license builder image
# or something, this would allow us to build license tainted software and
# then individual images that want to use it could set the license before
# emerging the binpkg
#+name: world-interlex
#+begin_src conf :tangle ./musl/interlex/world
dev-python/interlex
dev-libs/redland
#+end_src

** blazegraph
*** run
#+begin_src bash
docker run \
-v /var/lib/blazegraph:/var/lib/blazegraph \
-p 9999:9999 \
-it tgbugs/musl:blazegraph
#+end_src

*** build
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:blazegraph \
--file musl/blazegraph/Dockerfile musl/blazegraph
#+end_src

*** file
#+name: &musl/blazegraph
#+begin_src dockerfile :tangle ./musl/blazegraph/Dockerfile
ARG FEATURES="ebuild-locks"
<<&build-world-nox>>
ADD entrypoint.sh /etc/entrypoint.sh
ENTRYPOINT /etc/entrypoint.sh
#+end_src

*** world
#+name: world-blazegraph
#+begin_src conf :tangle ./musl/blazegraph/world
<<world-icedtea-nox>>
dev-db/blazegraph-bin
#+end_src

*** entrypoint
#+header: :shebang "#!/usr/bin/env sh"
#+begin_src bash :tangle ./musl/blazegraph/entrypoint.sh :mkdirp yes
rc-status
touch /run/openrc/softlevel
rc-service blazegraph start
#+end_src

** scigraph
*** run
#+begin_src bash
docker run \
-v /var/lib/scigraph:/var/lib/scigraph \
-p 9000:9000 \
tgbugs/musl:scigraph
#+end_src

*** build
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:scigraph \
--file musl/scigraph/Dockerfile musl/scigraph
#+end_src

*** file
#+name: &musl/scigraph
#+begin_src dockerfile :tangle ./musl/scigraph/Dockerfile
ARG FEATURES="ebuild-locks"
<<&build-world>>
ADD entrypoint.sh /etc/entrypoint.sh
ENTRYPOINT /etc/entrypoint.sh
#+end_src

*** world
#+name: world-scigraph
#+begin_src conf :tangle ./musl/scigraph/world
<<world-icedtea>>
dev-java/scigraph-bin
#+end_src

*** entrypoint
#+header: :shebang "#!/usr/bin/env sh"
#+begin_src bash :tangle ./musl/scigraph/entrypoint.sh :mkdirp yes
rc-status
touch /run/openrc/softlevel
rc-service scigraph start
#+end_src

** kg-release
Base environment for knowledge graph distribution and interaction.
Combines both server and client functionalities into a single image.
In principle this could be split into multiple images, but for the
sake of simplicity and reproducibility it is a single image.

*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-release
#+end_src

*** build
#+name: &musl-build-kg-release
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:kg-release \
--file musl/kg-release/Dockerfile musl/kg-release
#+end_src

*** file
# when deriving from multiple parent worlds docker does not compose
# well at all, so we have to pick a primary world line so to speak
#+name: &musl/kg-release
#+begin_src dockerfile :tangle ./musl/kg-release/Dockerfile
FROM tgbugs/musl:emacs

ARG FEATURES="ebuild-locks"  # scigraph and blazegraph pull in acct-{user,group}
<<&build-world-common>>
#+end_src

*** world
#+name: world-kg-release
#+begin_src conf :tangle ./musl/kg-release/world
<<world-emacs>>
<<world-icedtea>>
dev-db/blazegraph-bin
dev-java/scigraph-bin
media-gfx/graphviz
#+end_src

** kg-release-user
*** run
#+begin_src screen
docker run \
--volumes-from sckan-data \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-release-user
#+end_src

with configuration for xdg-open forwarding
#+begin_src screen
docker run \
--volumes-from sckan-data \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--add-host=host.docker.internal:host-gateway \
-e FORWARD_URL_HOST=host.docker.internal \
-e FORWARD_URL_PORT=59213 \
-it tgbugs/musl:kg-release-user
#+end_src

debug with network in bridge mode
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
--add-host local.binhost:127.0.0.1 \
--volumes-from sckan-data \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--add-host=host.docker.internal:host-gateway \
-e FORWARD_URL_HOST=host.docker.internal \
-e FORWARD_URL_PORT=59213 \
-it tgbugs/musl:kg-release-user
#+end_src

debug with host network
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
--add-host local.binhost:127.0.0.1 \
--volumes-from sckan-data \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--add-host=host.docker.internal:host-gateway \
--network=host \
-e FORWARD_URL_HOST=host.docker.internal \
-e FORWARD_URL_PORT=59213 \
-it tgbugs/musl:kg-release-user
#+end_src

*** build
#+name: &musl-build-kg-release-user
#+begin_src screen
_devel=
_docd=(queries.org)
_docsf="https://raw.githubusercontent.com/SciCrunch/sparc-curation/master/docs/"
_sckand=(welcome.org tutorial.org overview.org examples.org scratch.org README.org)
_docsfsc="${_docsf}sckan/"
pushd ./musl/kg-release-user
rm queries.org welcome.org tutorial.org overview.org examples.org scratch.org
if [ -n "${_devel}" ]; then
  cp -aL ~/git/sparc-curation/docs/sckan/*.org . ;
else
  for fn in ${_docd[@]};   do curl -O ${_docsf}${fn}  ; done
  for fn in ${_sckand[@]}; do curl -O ${_docsfsc}${fn}; done
fi
chmod +x ./queries.org
popd

<<&musl-build-kg-release-user-min>>
#+end_src

#+name: &musl-build-kg-release-user-min
#+begin_src screen
docker build \
--tag tgbugs/musl:kg-release-user \
--build-arg UID=${UID} \
--file musl/kg-release-user/Dockerfile musl/kg-release-user
#+end_src

*** entrypoints
Default interactive entrypoint.
#+header: :shebang "#!/usr/bin/env sh"
#+begin_src bash :tangle ./musl/kg-release-user/entrypoint.sh :mkdirp yes
rc-status
touch /run/openrc/softlevel
/etc/init.d/scigraph start
/etc/init.d/blazegraph start
su user -c 'emacs -geometry 120x40 -eval "(find-file-noselect (pop argv))" ~/welcome.org'
/etc/init.d/scigraph stop
/etc/init.d/blazegraph stop
#+end_src

Entrypoint to start services and run in the background.
#+header: :shebang "#!/usr/bin/env sh"
#+begin_src bash :tangle ./musl/kg-release-user/services.sh :mkdirp yes
rc-status
touch /run/openrc/softlevel
/etc/init.d/scigraph start
/etc/init.d/blazegraph start
#+end_src
*** file
# FIXME we should be able to stash the builder in this image
# and reuse it without having to rerun over and over ...
#+name: &musl/kg-release-user
#+begin_src dockerfile :tangle ./musl/kg-release-user/Dockerfile
FROM tgbugs/musl:kg-release as builder

<<&musl-user-skel-common>>

ARG HOME=/build/home/${USER_NAME}

WORKDIR $HOME

ADD --chown=${UID}:${UID} queries.org queries.org

USER ${USER_NAME}

RUN \
./queries.org

ADD --chown=${UID}:${UID} welcome.org welcome.org
ADD --chown=${UID}:${UID} tutorial.org tutorial.org
ADD --chown=${UID}:${UID} overview.org overview.org
ADD --chown=${UID}:${UID} examples.org examples.org
ADD --chown=${UID}:${UID} scratch.org scratch.org
ADD --chown=${UID}:${UID} README.org README.org

RUN \
emacs -batch -eval \
"(let ((user-init-file (pop argv))) (package-initialize) (while argv (orgstrap-whitelist-file (pop argv))))" \
$HOME/.emacs.d/init.el queries.org welcome.org examples.org scratch.org

FROM tgbugs/musl:kg-release

COPY --from=builder /build /

ADD services.sh /etc/services.sh
ADD entrypoint.sh /etc/entrypoint.sh

<<&musl-file-user-base>>

USER 0

RUN \
usermod -a -G blazegraph user \
;  usermod -a -G scigraph user \
;  usermod -a -G wheel user

RUN \
echo 'root:sparcSCKAN-2021' | chpasswd

# TODO when running this you will have to set the right mounts
# unless you bake a new kg-dev-with-data release
ENTRYPOINT /etc/entrypoint.sh
#+end_src

** kg-dev
*** run
# scigraph-build-local
# scigraph-deploy-local
# TODO package ontree server so that the updated local scigraph can be seen
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev
#+end_src

#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v /tmp/scigraph-build:/tmp/scigraph-build \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev \
echo TODO secrets, apinat build and more!
#+end_src

debug
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
--network host \
--add-host local.binhost:127.0.0.1 \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev
#+end_src

*** build
#+name: &musl-build-kg-dev
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:kg-dev \
--build-arg UID=${UID} \
--file musl/kg-dev/Dockerfile musl/kg-dev
#+end_src

*** world
#+name: world-kg-dev
#+begin_src conf :tangle ./musl/kg-dev/world
<<world-kg-release>>
app-misc/screen
dev-scheme/racket
net-libs/nodejs
app-arch/zip
app-misc/yq
dev-python/pip
dev-python/pyzmq
dev-java/robot-bin
dev-python/jupyter_core
#+end_src

*** file
#+name: &musl/kg-dev
#+begin_src dockerfile :tangle ./musl/kg-dev/Dockerfile
FROM tgbugs/musl:kg-release
<<&build-world-common>>

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
eselect racket set cs
#+end_src

** kg-dev-user
# FIXME somehow msising blazegraph user?
*** run
# TODO -v /var/lib/scigraph:/var/lib/scigraph \
#+begin_src screen
docker run \
--volumes-from sckan-data \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev-user
#+end_src

#+begin_src screen
docker run \
-v /var/lib/blazegraph:/var/lib/blazegraph \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:kg-dev-user
#+end_src

*** build
#+name: &musl-build-kg-dev-user
#+begin_src screen
docker build \
--tag tgbugs/musl:kg-dev-user \
--build-arg UID=${UID} \
--file musl/kg-dev-user/Dockerfile musl/kg-dev-user
#+end_src

*** entrypoint
#+begin_src bash
if [ -d /tmp/blazegraph ]; then
    cp /tmp/blazegraph/blazegraph.jnl /var/lib/blazegraph/
    cp /tmp/blazegraph/prefixes.conf /var/lib/blazegraph/
    chown -R blazegraph:blazegraph /var/lib/blazegraph
fi
#+end_src

#+header: :shebang "#!/usr/bin/env sh"
#+begin_src bash :tangle ./musl/kg-dev-user/entrypoint.sh :mkdirp yes
rc-status
touch /run/openrc/softlevel
/etc/init.d/scigraph start
/etc/init.d/blazegraph start
# screen ? or just emacs
su user -c 'emacs -visit ~/git/sparc-curation/docs/queries.org'
echo you have left the user shell, run '`su user`' to get another shell
/bin/bash
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/kg-dev-user/Dockerfile
FROM tgbugs/musl:kg-dev as builder

<<&musl-user-skel-common>>

USER ${USER_NAME}

ARG HOME=/build/home/${USER_NAME}

WORKDIR $HOME

ARG INIT_URL=https://raw.githubusercontent.com/tgbugs/orgstrap/master/init-simple.el

RUN \
emacs --batch --quick --eval "(progn (url-handler-mode 1) (find-file (pop argv)) (eval-buffer))" "${INIT_URL}"

RUN \
pushd ~/.emacs.d \
&& ln -s reval/cache/*/*-ow.el ow.el \
&& ln -s reval/cache/*/*-reval.el reval.el \
&& ln -s reval/cache/*/*-init-content.el init-content.el \
&& echo "(load (expand-file-name \"ow.el\" user-emacs-directory))" >> init.el \
&& echo "(load (expand-file-name \"reval.el\" user-emacs-directory))" >> init.el \
&& echo "(load (expand-file-name \"init-content.el\" user-emacs-directory))" >> init.el \
&& popd

RUN \
mkdir ~/git

# FIXME that is going to need to go in .bashrc or something
ENV PYTHONPYCACHEPREFIX=${HOME}/.cache/pycache/

# FIXME break these into their own images to avoid serial dependencies

# TODO https://github.com/Jannis234/jm-overlay seems to have node.eclass
# alternately we could try something similar to what we do for maven
# supply chain attacks become a problem, but it is no worse than what
# we have here
RUN \
pushd git \
&&     git clone https://github.com/open-physiology/open-physiology-viewer.git \
&&     pushd open-physiology-viewer \
&&         npm install \
&&         pushd wrapper \
&&             npm install \
&&         popd \
&&         npm run build \
&&         rm -r ./node_modules \
&&         rm -r ./wrapper/node_modules \
&&     popd \
&& popd \
&& ln -s ~/git/open-physiology-viewer/wrapper/bin/converter.js ~/.local/bin/apinat-converter \
&& rm -r ~/.npm/_cacache

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/pyontutils.git \
&&     pushd pyontutils \
&&         pushd ttlser \
&&             pip install --user -e . \
&&         popd \
&&         pip install --user -e . \
&&         python setup.py --release || true \
&&         pushd nifstd \
&&             pip install --user -e . \
&&             python setup.py --release || true \
&&         popd \
&&     popd \
&& popd \
&& rm -r ~/.cache/pip

RUN \
pushd git \
&&     git clone https://github.com/SciCrunch/sparc-curation.git \
&&     pushd sparc-curation \
&&         pip install --user -e . \
&&     popd \
&& popd \
&& rm -r ~/.cache/pip

RUN \
pushd git \
&&     git clone https://github.com/tgbugs/idlib.git \
&&     pushd idlib \
&&         pip install --user -e . \
&&     popd \
&& popd \
&& rm -r ~/.cache/pip

RUN \
./git/sparc-curation/docs/apinatomy.org

RUN \
./git/sparc-curation/docs/queries.org

# TODO embed orgstrap checksums for queries.org etc

FROM tgbugs/musl:kg-dev

COPY --from=builder /build /

ADD entrypoint.sh /etc/entrypoint.sh

<<&musl-file-user-base>>

USER 0

RUN \
usermod -a -G blazegraph user \
;  usermod -a -G scigraph user

# TODO when running this you will have to set the right mounts
# unless you bake a new kg-dev-with-data release
ENTRYPOINT /etc/entrypoint.sh
#+end_src
** sbcl
*** build
#+name: &musl-build-sbcl
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:sbcl \
--file musl/sbcl/Dockerfile musl/sbcl
#+end_src
*** file
#+begin_src dockerfile :tangle ./musl/sbcl/Dockerfile
FROM tgbugs/musl:static-binpkg-only
<<&build-world-common>>
#+end_src
*** world
#+name: world-sbcl
#+begin_src conf :tangle ./musl/sbcl/world
<<world-emacs>>
dev-lisp/uiop
dev-lisp/asdf
dev-lisp/sbcl
#+end_src
** sbcl-user
*** run
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:sbcl-user
#+end_src

*** build
#+name: &musl-build-sbcl-user
#+begin_src screen
docker build \
--tag tgbugs/musl:sbcl-user \
--build-arg UID=${UID} \
--file musl/sbcl-user/Dockerfile musl/sbcl-user
#+end_src

*** file
# TODO emacs setup etc.
#+begin_src dockerfile :tangle ./musl/sbcl-user/Dockerfile
FROM tgbugs/musl:sbcl

COPY --from=tgbugs/musl:user / /

<<&musl-file-user-base>>
#+end_src

** racket
*** build
#+name: &musl-build-racket
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:racket \
--file musl/racket/Dockerfile musl/racket
#+end_src

Build debug workflow.
#+begin_src bash
# if you have not done so already
docker create \
-v /var/db/repos/gentoo \
--name local-portage-snap \
gentoo/portage:latest \
/bin/true

# if you have you have to clear the container with
# docker rm local-portage-snap

# then
docker run \
--volumes-from local-portage-snap \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket
#+end_src

*** file
#+name: &musl/racket
#+begin_src dockerfile :tangle ./musl/racket/Dockerfile
FROM tgbugs/musl:emacs
<<&build-world-common>>

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
eselect racket set cs
#+end_src

*** world
#+name: world-racket
#+begin_src conf :tangle ./musl/racket/world
<<world-emacs>>
dev-scheme/racket
#+end_src
** racket-user
*** run
#+begin_src bash
# to allow the container access to the local x session you have to run the following
xhost local:docker
# use xhost -local:docker to remove

docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:racket-user
#+end_src

*** build
#+name: &musl-build-racket-user
#+begin_src bash
docker build \
--tag tgbugs/musl:racket-user \
--build-arg UID=${UID} \
--file musl/racket-user/Dockerfile musl/racket-user
#+end_src

*** file
#+name: &musl/racket-user
#+begin_src dockerfile :tangle ./musl/racket-user/Dockerfile
FROM tgbugs/musl:racket

COPY --from=tgbugs/musl:user / /

<<&musl-file-user-base>>
#+end_src

** dynapad-base
*** build
#+name: &musl-build-dynapad-base
#+begin_src screen
<<&docker-build>>
--tag tgbugs/musl:dynapad-base \
--file musl/dynapad-base/Dockerfile musl/dynapad-base
#+end_src
*** file
#+name: &musl/dynapad-base
#+begin_src dockerfile :tangle ./musl/dynapad-base/Dockerfile
FROM tgbugs/musl:racket
<<&build-world-common>>
#+end_src

*** world
#+name: world-dynapad-base
#+begin_src conf :tangle ./musl/dynapad-base/world
<<world-racket>>
dev-libs/libconfig
sys-libs/db
dev-lang/tk
media-gfx/imagemagick
app-text/poppler
#+end_src
** dynapad-user
*** build
#+name: &musl-build-dynapad-user
#+begin_src bash
docker build \
--tag tgbugs/musl:dynapad-user \
--build-arg UID=${UID} \
--file musl/dynapad-user/Dockerfile musl/dynapad-user
#+end_src

*** file
#+name: &musl/dynapad-user
#+begin_src dockerfile :tangle ./musl/dynapad-user/Dockerfile
FROM tgbugs/musl:dynapad-base

COPY --from=tgbugs/musl:user / /

<<&musl-file-user-base>>
#+end_src

** dynapad
*** run
Once you have created the =tgbugs/musl:dynapad= image (see the build
section below) you can use this command to run it and commit on close
each time so as not to lose any work. You will probably want to mount
any additional directories you will need .e.g for images using =-v=.

**** linux
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=$DISPLAY \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src
**** macos
See [[#macos-notes][macos notes]] for notes on getting docker working
with XQuartz.  Assuming everything is set up correctly you can the run
the following.
#+begin_src bash
docker run \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-e DISPLAY=host.docker.internal:0 \
-it tgbugs/musl:dynapad \
sh -c 'pushd ~/git/dynapad && racketcgc -it apps/paddraw/paddraw.rkt'

# docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

#+begin_src bash
xattr -d -r -s com.apple.quarantine /Applications/Docker.app
#+end_src

*** build
Since we need to mount the git directory from outside the image we
can't use a docker file. Commit the image after these steps are
finished (the commands above do that automatically).

If your UID is something other than 1000 you will probably want to
rebuild =tgbugs/musl:dynapad-user= so that your UID matches.

#+begin_src bash
docker pull tgbugs/musl:dynapad-user

docker run \
-v ~/git/dynapad:/home/dynapad/git/dynapad \
-it tgbugs/musl:dynapad-user
docker commit $(docker ps -lq) tgbugs/musl:dynapad
#+end_src

In the image run the following and then exit, the commit will be made
automatically. *NOTE* You may need to remove =build_musl= if it
already exists.
#+begin_src bash
pushd ~/git/dynapad
    mkdir build_musl
    pushd build_musl
        cmake .. -G Ninja
        ninja
    popd
    SUBPATH=$(racketcgc -e "(display (path->string (system-library-subpath)))")
    SO_SUFFIX=$(racketcgc -e "(display (bytes->string/utf-8 (system-type 'so-suffix)))")
    mkdir -p dynapad/compiled/bc/native/${SUBPATH}
    racocgc ctool --cgc \
            ++ldf -Wl,-rpath,"${PWD}/build_musl/" \
            --ld dynapad/compiled/bc/native/${SUBPATH}/libdynapad_rkt${SO_SUFFIX} \
            "${PWD}/build_musl/libdynapad${SO_SUFFIX}"
    racocgc pkg install collects/ dynapad/
    racocgc make apps/paddraw/paddraw.rkt
    racocgc make apps/uberapp/uberapp.rkt
#+end_src

** sparcur
*** world
#+name: world-sparcur
#+begin_src conf
dev-db/redis
net-misc/rabbitmq-server
#+end_src
** protc
*** world
#+name: world-protc
#+begin_src conf
dev-libs/redland
#+end_src
* gnu
may not need this if we can use crossdev to build glibc sbcl on musl that that seems a stretch
** profile
*** build
#+name: &gnu-build-profile
#+begin_src screen
docker build \
--tag tgbugs/gnu:profile \
--file gnu/profile/Dockerfile .
#+end_src

*** file
#+begin_src dockerfile :tangle ./gnu/profile/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

# we don't put this in var/db/repos because repos is managed via tgbugs/repos:latest
ADD docker-profile/base/docker-profile var/db/docker-profile
ADD docker-profile/base/docker-profile.conf etc/portage/repos.conf/docker-profile.conf
ADD docker-profile/base/binrepos-multi.conf etc/portage/binrepos.conf/multi.conf

FROM scratch

WORKDIR /
COPY --from=builder /build /
#+end_src

*** etc
**** binrepos.conf
#+begin_src conf :tangle ./gnu/profile/gnu.conf
[tgbugs-gnu]
priority = 100
sync-uri = http://local.binhost:8089/gnu
#+end_src
** eselect-repo
*** build
#+name: &gnu-build-eselect-repo
#+begin_src screen
docker build \
--tag tgbugs/gnu:eselect-repo \
--network host \
--add-host local.binhost:127.0.0.1 \
--file gnu/eselect-repo/Dockerfile gnu/eselect-repo
#+end_src

*** file
#+begin_src dockerfile :tangle ./gnu/eselect-repo/Dockerfile
FROM gentoo/stage3:hardened

<<&gentoo-file-eselect-repo-common-1>>

COPY --from=tgbugs/gnu:profile / /

<<&gentoo-file-eselect-repo-common-2>>

RUN \
eselect profile set docker-profile:tgbugs/gnu

<<&gentoo-file-eselect-repo-common-3>>
#+end_src

** sbcl-cross
*** run
#+begin_src bash
docker run \
--volumes-from local-repos-snap \
-v /mnt/str/portage/distfiles:/var/cache/distfiles \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
-it tgbugs/gnu:sbcl-cross
#+end_src

Test that the cross compiled version is working as expected.
#+begin_src bash
docker run \
-it tgbugs/gnu:sbcl-cross \
/usr/x86_64-pc-linux-musl/usr/bin/sbcl --core /usr/x86_64-pc-linux-musl/usr/lib/sbcl/sbcl.core
#+end_src
*** build
#+begin_src screen
docker build \
--tag tgbugs/gnu:sbcl-cross \
--network host \
--add-host local.binhost:127.0.0.1 \
--file gnu/sbcl-cross/Dockerfile gnu/sbcl-cross
#+end_src
*** file
#+begin_src dockerfile :tangle ./gnu/sbcl-cross/Dockerfile
FROM tgbugs/gnu:eselect-repo

#emerge -j4 -q -uDN \  # yeahno
RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q \
   --getbinpkg \
   --keep-going \
   sys-devel/crossdev \
<<&archive-or-rm>>

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge --usepkg --getbinpkgonly \
   cross-x86_64-pc-linux-musl/musl \
   cross-x86_64-pc-linux-musl/linux-headers \
   cross-x86_64-pc-linux-musl/gcc \
   cross-x86_64-pc-linux-musl/binutils \
;  crossdev --stable --target x86_64-pc-linux-musl --stage4 \
<<&archive-or-rm>>

# sbcl crossdev build looks in the wrong place for asdf and uiop
RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
emerge -j4 -q \
   --getbinpkg \
   --keep-going \
   dev-lisp/asdf \
   dev-lisp/uiop \
   dev-lisp/sbcl \
<<&archive-or-rm>>

ADD alt-ld.patch /etc/portage/patches/dev-lisp/sbcl/alt-ld.patch
ADD alt-ld.patch /usr/x86_64-pc-linux-musl/etc/portage/patches/dev-lisp/sbcl/alt-ld.patch
ADD 99-sbcl /usr/x86_64-pc-linux-musl/etc/portage/package.use/99-sbcl

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
x86_64-pc-linux-musl-emerge -j4 -q \
   --getbinpkg \
   --keep-going \
   sys-libs/musl \
   sys-libs/zlib \
<<&archive-or-rm>>

RUN \
ln -s /usr/x86_64-pc-linux-musl/usr/lib/libc.so /lib/ld-musl-x86_64.so.1

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
x86_64-pc-linux-musl-emerge -j4 -q \
   dev-lisp/asdf \
   dev-lisp/uiop \
   dev-lisp/sbcl \
<<&archive-or-rm>>
#+end_src

Until we can figure out how to get the cross build to link this
correctly we leave it out.  We don't really need it since this build
is only for a bootstrapping sbcl on musl. There are native ways to do
this inside of the sbcl toolset itself, but for now this is easier.
# */* static-libs static
#+begin_src conf :tangle ./gnu/sbcl-cross/99-sbcl
dev-lisp/sbcl -zlib  # crossdev compile reference errors
#+end_src

#+begin_src diff :tangle ./gnu/sbcl-cross/alt-ld.patch
diff --git a/make-target-contrib.sh b/make-target-contrib.sh
index 217b5b2e0..45406f506 100755
--- a/make-target-contrib.sh
+++ b/make-target-contrib.sh
@@ -29,8 +29,12 @@ if [ -z "$CC" ]; then
     fi
 fi
 
+if [ -z "${LD}" ]; then
+    LD=ld
+fi
+
 unset EXTRA_CFLAGS # avoid any potential interference 
-export CC LANG LC_ALL
+export CC LD LANG LC_ALL
 
 # Load our build configuration
 . output/build-config
diff --git a/src/runtime/GNUmakefile b/src/runtime/GNUmakefile
index 0543c1244..284755e5c 100644
--- a/src/runtime/GNUmakefile
+++ b/src/runtime/GNUmakefile
@@ -24,7 +24,6 @@ SBCL_PAXCTL ?= :
 LINKFLAGS += -g
 DEPEND_FLAGS = -MM
 GREP = grep
-LD = ld
 
 # By default, don't make and use a library, just use the object files.
 LIBSBCL = $(OBJS)
#+end_src

#+begin_src bash
git clone https://github.com/sbcl/sbcl.git
pushd sbcl
git remote add daewok https://github.com/daewok/sbcl.git
git fetch daewok
git checkout daewok/static-executable
#+end_src

** musl/cross/sbcl
*** build
#+begin_src screen
docker build \
--tag tgbugs/musl:cross-sbcl \
--file musl/cross/sbcl/Dockerfile musl/cross/sbcl

docker rm cross-sbcl
docker create -v /sbcl --name cross-sbcl tgbugs/musl:cross-sbcl /bin/true
#+end_src

*** file
#+begin_src dockerfile :tangle ./musl/cross/sbcl/Dockerfile
FROM busybox:latest

WORKDIR /

COPY --from=tgbugs/gnu:sbcl-cross /usr/x86_64-pc-linux-musl/usr/lib/sbcl /sbcl
COPY --from=tgbugs/gnu:sbcl-cross /usr/x86_64-pc-linux-musl/usr/bin/sbcl /sbcl/src/runtime/sbcl

RUN \
mkdir -p /sbcl/obj/sbcl-home \
&& ln -s /sbcl/contrib /sbcl/obj/sbcl-home/contrib \
&& mkdir -p /sbcl/output \
&& ln -s /sbcl/sbcl.core /sbcl/output/sbcl.core

VOLUME /sbcl
#+end_src

* other
** ubuntu-genera-base
*** file
#+begin_src dockerfile :tangle ./other/ubuntu-genera-base/Dockerfile
FROM ubuntu:18.04

RUN apt update

RUN apt install -y \
curl \
inetutils-inetd \
vim \
telnet \
nfs-common \
nfs-kernel-server \
iproute2 \
libx11-6 \
xserver-xephyr \
x11-xserver-utils \
iputils-ping
#+end_src

*** build
# docker pull ubuntu:18.04
# docker run -it ubuntu:18.04

#+begin_src bash
docker build \
--tag tgbugs/other:ubuntu-genera-base \
--file other/ubuntu-genera-base/Dockerfile other/ubuntu-genera-base
#+end_src

** genera
A docker file that specifies and image that can run Open Genera 2.0.

We can't distribute the final image for a variety of reasons, however
the configured base image can be distributed and is a valuable
resource as a result.

Useful as a starting point for debugging why it won't work on other systems.

Nearly everything is working except that docker and NFS exports seem
to be fighting with each other.  Old comments on the web mention
issues with exporting overlayfs mounts to NFS, but this commit from
2017 <https://patchwork.kernel.org/project/linux-fsdevel/patch/
1508258671-10800-15-git-send-email-amir73il@gmail.com/> seems to have
fixed that issue.

Three entry points.
https://www.reddit.com/r/lisp/comments/lhsltk/lisp_implementations_similiar_to_old_lisp_machines/
https://gist.github.com/oubiwann/1e7aadfc22e3ae908921aeaccf27e82d
https://archives.loomcom.com/genera/genera-install.html
*** exploration
This will eventually become a docker file, but right now it is still
too experimental so the workflow is run and commit rather than build.

#+begin_src bash
xhost local:docker

# NET_ADMIN apparently needed for tuntap creation (bsd jails and vnets looking really good right now)
# SYS_ADMIN apparently needed to get NFS exports to work (bsd jails looking even better!?)
# generally though this is ok because we are really only using this docker image as a way to get
# an environment where genera will run

docker run -it \
-v ~/files/tmp/genera:/files \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e DISPLAY=$DISPLAY \
--device /dev/net/tun \
--cap-add NET_ADMIN \
--cap-add SYS_ADMIN \
tgbugs/other:ubuntu-genera-base
#+end_src

In the docker shell (will become the docker file or a script run in the docker file)
#+begin_src bash
#mkdir -p /dev/net
#mknod /dev/net/tun c 10 200

# tunnel creation
# ip tuntap delete dev tap0 mode tap  # to remove since it fights with the host
ip tuntap add dev tap0 mode tap
ip addr add 192.168.2.1/24 dev tap0
ip link set dev tap0 up

# inetd

echo "time      stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "time      dgram   udp  wait   root internal" >> /etc/inetd.conf
echo "daytime   stream  tcp  nowait root internal" >> /etc/inetd.conf
echo "daytime   dgram   udp  wait   root internal" >> /etc/inetd.conf

service inetutils-inetd restart

# retrieve genera files TODO snapshot these to reduce redownload

mkdir genera
pushd genera
curl -LO https://archives.loomcom.com/genera/genera
chmod a+x genera
curl -L -O https://archives.loomcom.com/genera/worlds/Genera-8-5-xlib-patched.vlod
curl -L -O https://archives.loomcom.com/genera/worlds/VLM_debugger
curl -L -O https://archives.loomcom.com/genera/worlds/dot.VLM
mv dot.VLM .VLM
mkdir lib
pushd lib
curl -L -O https://archives.loomcom.com/genera/var_lib_symbolics.tar.gz
tar xvf var_lib_symbolics.tar.gz
chown -R root:root symbolics
ln -s /genera/lib/symbolics /var/lib/symbolics  # may fail
popd

sed -i 's,/home/seth,,' .VLM
echo "192.168.2.1    genera-vlm" >> /etc/hosts
echo "192.168.2.2    genera" >> /etc/hosts

# nfs XXX TODO broken

echo 'RPCNFSDCOUNT="--nfs-version 2 8"' >> /etc/default/nfs-kernel-server
echo 'RPCMOUNTDOPTS="--nfs-version 2 --manage-gids"' >> /etc/default/nfs-kernel-server
echo "/files genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports
# we really want to export / but I'm seeing the following error
# exportfs: / does not support NFS export
#echo "/ genera(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000)" >> /etc/exports

# I think rpcbind needs be be started, otherwise nfs-kernel-server may fail to start
# and/or NFS will not work at all
service rpcbind start

service nfs-kernel-server restart

# start genera using host X server

DISPLAY=:0.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

# start genera using Xephyr (a bit more stable/predictable)

DISPLAY=:0.0; Xephyr -br -reset -terminate -ac -noreset -screen 1280x1024 :3 &
DISPLAY=:3.0; ./genera -coldloadgeometry 640x480+0+0 -geometry 1280x1024+0+0 &

#+end_src
* sckan
** save
To save a gzipped archive run
#+begin_src bash
# first run the following to find the latest build, then
docker image ls tgbugs/sckan:data-*
docker save tgbugs/sckan:data-2021-09-30T232453Z | gzip > /tmp/docker-sckan-data-2021-09-30T232453Z.tar.gz
#+end_src

To restore from the archive run
#+begin_src bash
docker load --input sckan-data-2021-09-30T232453Z.tar.gz
#+end_src
** services
This combines the raw (data) base image with prefixes.conf and services.yaml.
Note that the image names for these are shifted so that they don't confuse users.
The logic is that base + services = data, but users don't know anything about services.

*** container
#+begin_src bash
docker container inspect sckan-data > /dev/null && \
docker rm sckan-data
docker create -v /var/lib/blazegraph -v /var/lib/scigraph --name sckan-data tgbugs/sckan:latest /bin/true
#+end_src

*** build
#+name: &musl-build-sckan-services
#+begin_src screen
mkdir -p ./sckan/services/blazegraph

[ -d ./sckan/services/scigraph ] && rm -r ./sckan/services/scigraph
mkdir -p ./sckan/services/scigraph

pushd ./sckan/services

# blazegraph
_sckanl="$(ls -d /tmp/build/release-*-sckan | sort -u | tail -n 1)"
rsync -a ${_sckanl}/data/prefixes.conf blazegraph/

# scigraph
~/git/pyontutils/nifstd/scigraph/bin/run-build-services-sparc
rsync -a /tmp/scigraph-build/sparc/services.yaml scigraph/
rsync -a /tmp/scigraph-build/sparc/$(head -n 1 scigraph/services.yaml | cut -b3-) scigraph/

popd

docker build \
--tag tgbugs/sckan:data-$(date --utc +%Y-%m-%dT%H%M%SZ) \
--tag tgbugs/sckan:latest \
--file sckan/services/Dockerfile sckan/services
#+end_src

*** file
#+begin_src dockerfile :tangle ./sckan/services/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD --chown=834:834 blazegraph/ /build/var/lib/blazegraph
ADD --chown=835:835 scigraph/ /build/var/lib/scigraph

FROM tgbugs/sckan:base-latest
COPY --from=builder /build /
#+end_src

** base
*** build
# TODO release snapshots for these images

# FIXME scigraph log folder ownership is still fucked after all these years ffs
#+name: &musl-build-sckan-base
#+begin_src screen
mkdir -p ./sckan/base/blazegraph

[ -d ./sckan/base/scigraph ] && rm -r ./sckan/base/scigraph
mkdir -p ./sckan/base/scigraph

pushd ./sckan/base

_sckanl="$(ls -d /tmp/build/release-*-sckan | sort -u | tail -n 1)"
rsync -a ${_sckanl}/data/blazegraph.jnl blazegraph/

# TODO run-load-graph-sparc-sckan
_zip=$(realpath /tmp/scigraph-build/sparc-sckan/LATEST)
_path="${_zip%.*}"
_scigr="${_path##*/}"
rsync -a ${_path} scigraph/
ln -s /var/lib/scigraph/${_scigr} scigraph/graph

popd

docker build \
--tag tgbugs/sckan:base-$(date --utc +%Y-%m-%dT%H%M%SZ) \
--tag tgbugs/sckan:base-latest \
--file sckan/base/Dockerfile sckan/base
#+end_src

*** file
# /build/sckan/ this could include the provenance data, but I think we should probably leave it out?
# TODO also consider splitting blazegraph and scigraph volume images ?
# TODO have a version of this that does the builds itself instead of just copying everything in
#+begin_src dockerfile :tangle ./sckan/base/Dockerfile
FROM busybox:latest as builder

WORKDIR /build

ADD --chown=834:834 blazegraph/ /build/var/lib/blazegraph
ADD --chown=835:835 scigraph/ /build/var/lib/scigraph

FROM scratch
COPY --from=builder /build /
#+end_src

* utils :noexport:
# FIXME --network host is ok for now, but we should probably try to
# switch to using --ssh or something since it is needed for building
# all binpkg-only images
#+name: &docker-build
#+begin_src bash
docker build \
--network host \
--add-host local.binhost:127.0.0.1 \
#+end_src

#+name: &build-world
#+begin_src dockerfile
FROM tgbugs/musl:binpkg-only
<<&build-world-common>>
#+end_src

#+name: &build-world-nox
#+begin_src dockerfile
FROM tgbugs/musl:binpkg-only-nox
<<&build-world-common>>
#+end_src

#+name: &build-world-common
#+begin_src dockerfile

ARG ARCHIVE

ADD world /var/lib/portage/world

RUN --mount=from=tgbugs/repos:latest,source=/var/db/repos,target=/var/db/repos,rw \
cat /var/lib/portage/world | xargs emerge -j4 -q -uDN \
<<&archive-or-rm>>
#+end_src

#+name: &archive-or-rm
#+begin_src dockerfile
;  export CODE=$? \
;  echo CODE $CODE \
;  [[ -n ${ARCHIVE} ]] \
|| { rm -r /var/cache/distfiles/* > /dev/null 2>&1 \
   ; rm -r /var/cache/binpkgs/* > /dev/null 2>&1; } \
;  exit $CODE
#+end_src
* Bootstrap :noexport:

#+name: orgstrap
#+begin_src elisp :results none :lexical yes
(defvar-local workflow-refresh nil)
(defvar-local workflow-repos nil)

(defun fix-ocbe ()
  "it would seem that blanking `enable-local-eval' resets this"
  (setq-local
   org-confirm-babel-evaluate
   (lambda (lang body)
     (not (and (member lang '("elisp" "emacs-lisp"))
               (string= body "value"))))))

(defun dedupe-lines (blockname)
  (let* ((info (save-excursion
                 (org-save-outline-visibility 'use-markers
                   (let ((obs (org-babel-find-named-block blockname)))
                     (if obs (goto-char obs)
                       (error "No block named %s" blockname)))
                   (org-babel-get-src-block-info))))
         (body (org-babel--expand-body info)))
    (string-join (sort (cl-remove-duplicates
                        (split-string body "\n")
                        :test #'string=)
                       #'string<)
                 "\n")))

(fix-ocbe)

(when noninteractive
  (setq args nil)
  (unless (fboundp #'dockerfile-mode)
    (define-derived-mode dockerfile-mode prog-mode "Dockerfile"
      "Stub to avoid comment-start issues"
      (set (make-local-variable 'comment-start) "#")))
  (let (enable-local-eval)
    ;; this pattern is required when tangling to avoid infinite loops
    (revert-buffer nil t nil)
    (setq-local find-file-literally nil))
  (fix-ocbe)
  (org-babel-tangle))
#+end_src

Helper block to make it easier to use elisp functions as noweb inputs.
#+name: ident
#+begin_src elisp :var value=""
value
#+end_src

** Local Variables :ARCHIVE:
# close powershell comment #>
# Local Variables:
# eval: (progn (setq-local orgstrap-min-org-version "8.2.10") (let ((actual (org-version)) (need orgstrap-min-org-version)) (or (fboundp #'orgstrap--confirm-eval) (not need) (string< need actual) (string= need actual) (error "Your Org is too old! %s < %s" actual need))) (defun orgstrap-norm-func--prp-1\.1 (body) (let (print-quoted print-length print-level) (prin1-to-string (read (concat "(progn\n" body "\n)"))))) (unless (boundp 'orgstrap-norm-func) (defvar orgstrap-norm-func orgstrap-norm-func-name)) (defun orgstrap-norm-embd (body) (funcall orgstrap-norm-func body)) (unless (fboundp #'orgstrap-norm) (defalias 'orgstrap-norm #'orgstrap-norm-embd)) (defun orgstrap-org-src-coderef-regexp (_fmt &optional label) (let ((fmt org-coderef-label-format)) (format "\\([:blank:]*\\(%s\\)[:blank:]*\\)$" (replace-regexp-in-string "%s" (if label (regexp-quote label) "\\([-a-zA-Z0-9_][-a-zA-Z0-9_ ]*\\)") (regexp-quote fmt) nil t)))) (unless (fboundp #'org-src-coderef-regexp) (defalias 'org-src-coderef-regexp #'orgstrap-org-src-coderef-regexp)) (defun orgstrap--expand-body (info) (let ((coderef (nth 6 info)) (expand (if (org-babel-noweb-p (nth 2 info) :eval) (org-babel-expand-noweb-references info) (nth 1 info)))) (if (not coderef) expand (replace-regexp-in-string (org-src-coderef-regexp coderef) "" expand nil nil 1)))) (defun orgstrap--confirm-eval-portable (lang _body) (not (and (member lang '("elisp" "emacs-lisp")) (let* ((body (orgstrap--expand-body (org-babel-get-src-block-info))) (body-normalized (orgstrap-norm body)) (content-checksum (intern (secure-hash orgstrap-cypher body-normalized)))) (eq orgstrap-block-checksum content-checksum))))) (unless (fboundp #'orgstrap--confirm-eval) (defalias 'orgstrap--confirm-eval #'orgstrap--confirm-eval-portable)) (let (enable-local-eval) (vc-find-file-hook)) (let ((obs (org-babel-find-named-block "orgstrap"))) (if obs (unwind-protect (save-excursion (setq-local orgstrap-norm-func orgstrap-norm-func-name) (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval) (goto-char obs) (org-babel-execute-src-block)) (org-set-startup-visibility)) (warn "No orgstrap block."))))
# End:
